/* tslint:disable */
/* eslint-disable */
/**
 * Talon.One API
 * Use the Talon.One API to integrate with your application and to manage applications and campaigns:  - Use the operations in the [Integration API section](#integration-api) are used to integrate with our platform - Use the operation in the [Management API section](#management-api) to manage applications and campaigns.  ## Determining the base URL of the endpoints  The API is available at the same hostname as your Campaign Manager deployment. For example, if you access the Campaign Manager at `https://yourbaseurl.talon.one/`, the URL for the [updateCustomerSessionV2](https://docs.talon.one/integration-api#operation/updateCustomerSessionV2) endpoint is `https://yourbaseurl.talon.one/v2/customer_sessions/{Id}` 
 *
 * The version of the OpenAPI document: 
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Account,
  AccountAdditionalCost,
  AccountAnalytics,
  Achievement,
  ActivateUserRequest,
  AddLoyaltyPoints,
  Application,
  ApplicationApiHealth,
  ApplicationCustomer,
  ApplicationSession,
  AsyncCouponCreationResponse,
  AsyncCouponDeletionJobResponse,
  Attribute,
  Campaign,
  CampaignCopy,
  CampaignGroup,
  CampaignSearch,
  Collection,
  Coupon,
  CreateAchievement,
  CreateCoupons200Response,
  CreateTemplateCampaign,
  CreateTemplateCampaignResponse,
  CustomerActivityReport,
  CustomerAnalytics,
  CustomerProfile,
  CustomerProfileSearchQuery,
  DeactivateUserRequest,
  DeductLoyaltyPoints,
  DeleteUserRequest,
  ErrorResponse,
  ErrorResponseWithStatus,
  GenerateCouponRejections200Response,
  GetAccessLogsWithoutTotalCount200Response,
  GetAdditionalCosts200Response,
  GetApplicationCustomerFriends200Response,
  GetApplicationCustomers200Response,
  GetApplicationCustomersByAttributes200Response,
  GetApplicationEventTypes200Response,
  GetApplicationEventsWithoutTotalCount200Response,
  GetApplicationSessions200Response,
  GetApplications200Response,
  GetAttributes200Response,
  GetAudienceMemberships200Response,
  GetAudiences200Response,
  GetAudiencesAnalytics200Response,
  GetCampaignAnalytics200Response,
  GetCampaignGroups200Response,
  GetCampaignTemplates200Response,
  GetCampaigns200Response,
  GetChanges200Response,
  GetCollectionItems200Response,
  GetCouponsWithoutTotalCount200Response,
  GetCustomerActivityReportsWithoutTotalCount200Response,
  GetCustomerProfileAchievementProgress200Response,
  GetCustomerProfiles200Response,
  GetCustomersByAttributes200Response,
  GetDashboardStatistics200Response,
  GetEventTypes200Response,
  GetExports200Response,
  GetLoyaltyCardTransactionLogs200Response,
  GetLoyaltyCards200Response,
  GetLoyaltyProgramProfileTransactions200Response,
  GetLoyaltyProgramTransactions200Response,
  GetLoyaltyPrograms200Response,
  GetReferralsWithoutTotalCount200Response,
  GetRulesets200Response,
  GetUsers200Response,
  GetWebhooks200Response,
  Import,
  ListAccountCollections200Response,
  ListAchievements200Response,
  ListAllRolesV2200Response,
  ListCampaignStoreBudgetLimits200Response,
  ListCatalogItems200Response,
  ListStores200Response,
  LoginParams,
  LoyaltyBalancesWithTiers,
  LoyaltyCard,
  LoyaltyCardBatch,
  LoyaltyCardBatchResponse,
  LoyaltyDashboardData,
  LoyaltyLedger,
  LoyaltyProgram,
  MessageLogEntries,
  NewAdditionalCost,
  NewAttribute,
  NewCampaignCollection,
  NewCampaignStoreBudget,
  NewCollection,
  NewCouponCreationJob,
  NewCouponDeletionJob,
  NewCoupons,
  NewCouponsForMultipleRecipients,
  NewExternalInvitation,
  NewInvitation,
  NewInviteEmail,
  NewPassword,
  NewPasswordEmail,
  NewStore,
  Referral,
  RoleV2,
  RoleV2Base,
  Ruleset,
  ScimBaseGroup,
  ScimGroup,
  ScimGroupsListResponse,
  ScimNewUser,
  ScimPatchRequest,
  ScimResourceTypesListResponse,
  ScimSchemasListResponse,
  ScimServiceProviderConfigResponse,
  ScimUser,
  ScimUsersListResponse,
  Session,
  Store,
  SummarizeCampaignStoreBudget200Response,
  TransferLoyaltyCard,
  UpdateAchievement,
  UpdateCampaign,
  UpdateCampaignCollection,
  UpdateCollection,
  UpdateCoupon,
  UpdateCouponBatch,
  UpdateLoyaltyCard,
  UpdateReferral,
  UpdateUser,
  User,
  Webhook,
} from '../models/index';
import {
    AccountFromJSON,
    AccountToJSON,
    AccountAdditionalCostFromJSON,
    AccountAdditionalCostToJSON,
    AccountAnalyticsFromJSON,
    AccountAnalyticsToJSON,
    AchievementFromJSON,
    AchievementToJSON,
    ActivateUserRequestFromJSON,
    ActivateUserRequestToJSON,
    AddLoyaltyPointsFromJSON,
    AddLoyaltyPointsToJSON,
    ApplicationFromJSON,
    ApplicationToJSON,
    ApplicationApiHealthFromJSON,
    ApplicationApiHealthToJSON,
    ApplicationCustomerFromJSON,
    ApplicationCustomerToJSON,
    ApplicationSessionFromJSON,
    ApplicationSessionToJSON,
    AsyncCouponCreationResponseFromJSON,
    AsyncCouponCreationResponseToJSON,
    AsyncCouponDeletionJobResponseFromJSON,
    AsyncCouponDeletionJobResponseToJSON,
    AttributeFromJSON,
    AttributeToJSON,
    CampaignFromJSON,
    CampaignToJSON,
    CampaignCopyFromJSON,
    CampaignCopyToJSON,
    CampaignGroupFromJSON,
    CampaignGroupToJSON,
    CampaignSearchFromJSON,
    CampaignSearchToJSON,
    CollectionFromJSON,
    CollectionToJSON,
    CouponFromJSON,
    CouponToJSON,
    CreateAchievementFromJSON,
    CreateAchievementToJSON,
    CreateCoupons200ResponseFromJSON,
    CreateCoupons200ResponseToJSON,
    CreateTemplateCampaignFromJSON,
    CreateTemplateCampaignToJSON,
    CreateTemplateCampaignResponseFromJSON,
    CreateTemplateCampaignResponseToJSON,
    CustomerActivityReportFromJSON,
    CustomerActivityReportToJSON,
    CustomerAnalyticsFromJSON,
    CustomerAnalyticsToJSON,
    CustomerProfileFromJSON,
    CustomerProfileToJSON,
    CustomerProfileSearchQueryFromJSON,
    CustomerProfileSearchQueryToJSON,
    DeactivateUserRequestFromJSON,
    DeactivateUserRequestToJSON,
    DeductLoyaltyPointsFromJSON,
    DeductLoyaltyPointsToJSON,
    DeleteUserRequestFromJSON,
    DeleteUserRequestToJSON,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    ErrorResponseWithStatusFromJSON,
    ErrorResponseWithStatusToJSON,
    GenerateCouponRejections200ResponseFromJSON,
    GenerateCouponRejections200ResponseToJSON,
    GetAccessLogsWithoutTotalCount200ResponseFromJSON,
    GetAccessLogsWithoutTotalCount200ResponseToJSON,
    GetAdditionalCosts200ResponseFromJSON,
    GetAdditionalCosts200ResponseToJSON,
    GetApplicationCustomerFriends200ResponseFromJSON,
    GetApplicationCustomerFriends200ResponseToJSON,
    GetApplicationCustomers200ResponseFromJSON,
    GetApplicationCustomers200ResponseToJSON,
    GetApplicationCustomersByAttributes200ResponseFromJSON,
    GetApplicationCustomersByAttributes200ResponseToJSON,
    GetApplicationEventTypes200ResponseFromJSON,
    GetApplicationEventTypes200ResponseToJSON,
    GetApplicationEventsWithoutTotalCount200ResponseFromJSON,
    GetApplicationEventsWithoutTotalCount200ResponseToJSON,
    GetApplicationSessions200ResponseFromJSON,
    GetApplicationSessions200ResponseToJSON,
    GetApplications200ResponseFromJSON,
    GetApplications200ResponseToJSON,
    GetAttributes200ResponseFromJSON,
    GetAttributes200ResponseToJSON,
    GetAudienceMemberships200ResponseFromJSON,
    GetAudienceMemberships200ResponseToJSON,
    GetAudiences200ResponseFromJSON,
    GetAudiences200ResponseToJSON,
    GetAudiencesAnalytics200ResponseFromJSON,
    GetAudiencesAnalytics200ResponseToJSON,
    GetCampaignAnalytics200ResponseFromJSON,
    GetCampaignAnalytics200ResponseToJSON,
    GetCampaignGroups200ResponseFromJSON,
    GetCampaignGroups200ResponseToJSON,
    GetCampaignTemplates200ResponseFromJSON,
    GetCampaignTemplates200ResponseToJSON,
    GetCampaigns200ResponseFromJSON,
    GetCampaigns200ResponseToJSON,
    GetChanges200ResponseFromJSON,
    GetChanges200ResponseToJSON,
    GetCollectionItems200ResponseFromJSON,
    GetCollectionItems200ResponseToJSON,
    GetCouponsWithoutTotalCount200ResponseFromJSON,
    GetCouponsWithoutTotalCount200ResponseToJSON,
    GetCustomerActivityReportsWithoutTotalCount200ResponseFromJSON,
    GetCustomerActivityReportsWithoutTotalCount200ResponseToJSON,
    GetCustomerProfileAchievementProgress200ResponseFromJSON,
    GetCustomerProfileAchievementProgress200ResponseToJSON,
    GetCustomerProfiles200ResponseFromJSON,
    GetCustomerProfiles200ResponseToJSON,
    GetCustomersByAttributes200ResponseFromJSON,
    GetCustomersByAttributes200ResponseToJSON,
    GetDashboardStatistics200ResponseFromJSON,
    GetDashboardStatistics200ResponseToJSON,
    GetEventTypes200ResponseFromJSON,
    GetEventTypes200ResponseToJSON,
    GetExports200ResponseFromJSON,
    GetExports200ResponseToJSON,
    GetLoyaltyCardTransactionLogs200ResponseFromJSON,
    GetLoyaltyCardTransactionLogs200ResponseToJSON,
    GetLoyaltyCards200ResponseFromJSON,
    GetLoyaltyCards200ResponseToJSON,
    GetLoyaltyProgramProfileTransactions200ResponseFromJSON,
    GetLoyaltyProgramProfileTransactions200ResponseToJSON,
    GetLoyaltyProgramTransactions200ResponseFromJSON,
    GetLoyaltyProgramTransactions200ResponseToJSON,
    GetLoyaltyPrograms200ResponseFromJSON,
    GetLoyaltyPrograms200ResponseToJSON,
    GetReferralsWithoutTotalCount200ResponseFromJSON,
    GetReferralsWithoutTotalCount200ResponseToJSON,
    GetRulesets200ResponseFromJSON,
    GetRulesets200ResponseToJSON,
    GetUsers200ResponseFromJSON,
    GetUsers200ResponseToJSON,
    GetWebhooks200ResponseFromJSON,
    GetWebhooks200ResponseToJSON,
    ImportFromJSON,
    ImportToJSON,
    ListAccountCollections200ResponseFromJSON,
    ListAccountCollections200ResponseToJSON,
    ListAchievements200ResponseFromJSON,
    ListAchievements200ResponseToJSON,
    ListAllRolesV2200ResponseFromJSON,
    ListAllRolesV2200ResponseToJSON,
    ListCampaignStoreBudgetLimits200ResponseFromJSON,
    ListCampaignStoreBudgetLimits200ResponseToJSON,
    ListCatalogItems200ResponseFromJSON,
    ListCatalogItems200ResponseToJSON,
    ListStores200ResponseFromJSON,
    ListStores200ResponseToJSON,
    LoginParamsFromJSON,
    LoginParamsToJSON,
    LoyaltyBalancesWithTiersFromJSON,
    LoyaltyBalancesWithTiersToJSON,
    LoyaltyCardFromJSON,
    LoyaltyCardToJSON,
    LoyaltyCardBatchFromJSON,
    LoyaltyCardBatchToJSON,
    LoyaltyCardBatchResponseFromJSON,
    LoyaltyCardBatchResponseToJSON,
    LoyaltyDashboardDataFromJSON,
    LoyaltyDashboardDataToJSON,
    LoyaltyLedgerFromJSON,
    LoyaltyLedgerToJSON,
    LoyaltyProgramFromJSON,
    LoyaltyProgramToJSON,
    MessageLogEntriesFromJSON,
    MessageLogEntriesToJSON,
    NewAdditionalCostFromJSON,
    NewAdditionalCostToJSON,
    NewAttributeFromJSON,
    NewAttributeToJSON,
    NewCampaignCollectionFromJSON,
    NewCampaignCollectionToJSON,
    NewCampaignStoreBudgetFromJSON,
    NewCampaignStoreBudgetToJSON,
    NewCollectionFromJSON,
    NewCollectionToJSON,
    NewCouponCreationJobFromJSON,
    NewCouponCreationJobToJSON,
    NewCouponDeletionJobFromJSON,
    NewCouponDeletionJobToJSON,
    NewCouponsFromJSON,
    NewCouponsToJSON,
    NewCouponsForMultipleRecipientsFromJSON,
    NewCouponsForMultipleRecipientsToJSON,
    NewExternalInvitationFromJSON,
    NewExternalInvitationToJSON,
    NewInvitationFromJSON,
    NewInvitationToJSON,
    NewInviteEmailFromJSON,
    NewInviteEmailToJSON,
    NewPasswordFromJSON,
    NewPasswordToJSON,
    NewPasswordEmailFromJSON,
    NewPasswordEmailToJSON,
    NewStoreFromJSON,
    NewStoreToJSON,
    ReferralFromJSON,
    ReferralToJSON,
    RoleV2FromJSON,
    RoleV2ToJSON,
    RoleV2BaseFromJSON,
    RoleV2BaseToJSON,
    RulesetFromJSON,
    RulesetToJSON,
    ScimBaseGroupFromJSON,
    ScimBaseGroupToJSON,
    ScimGroupFromJSON,
    ScimGroupToJSON,
    ScimGroupsListResponseFromJSON,
    ScimGroupsListResponseToJSON,
    ScimNewUserFromJSON,
    ScimNewUserToJSON,
    ScimPatchRequestFromJSON,
    ScimPatchRequestToJSON,
    ScimResourceTypesListResponseFromJSON,
    ScimResourceTypesListResponseToJSON,
    ScimSchemasListResponseFromJSON,
    ScimSchemasListResponseToJSON,
    ScimServiceProviderConfigResponseFromJSON,
    ScimServiceProviderConfigResponseToJSON,
    ScimUserFromJSON,
    ScimUserToJSON,
    ScimUsersListResponseFromJSON,
    ScimUsersListResponseToJSON,
    SessionFromJSON,
    SessionToJSON,
    StoreFromJSON,
    StoreToJSON,
    SummarizeCampaignStoreBudget200ResponseFromJSON,
    SummarizeCampaignStoreBudget200ResponseToJSON,
    TransferLoyaltyCardFromJSON,
    TransferLoyaltyCardToJSON,
    UpdateAchievementFromJSON,
    UpdateAchievementToJSON,
    UpdateCampaignFromJSON,
    UpdateCampaignToJSON,
    UpdateCampaignCollectionFromJSON,
    UpdateCampaignCollectionToJSON,
    UpdateCollectionFromJSON,
    UpdateCollectionToJSON,
    UpdateCouponFromJSON,
    UpdateCouponToJSON,
    UpdateCouponBatchFromJSON,
    UpdateCouponBatchToJSON,
    UpdateLoyaltyCardFromJSON,
    UpdateLoyaltyCardToJSON,
    UpdateReferralFromJSON,
    UpdateReferralToJSON,
    UpdateUserFromJSON,
    UpdateUserToJSON,
    UserFromJSON,
    UserToJSON,
    WebhookFromJSON,
    WebhookToJSON,
} from '../models/index';

export interface ActivateUserByEmailRequest {
    activateUserRequest: ActivateUserRequest;
}

export interface AddLoyaltyCardPointsRequest {
    loyaltyProgramId: number;
    loyaltyCardId: string;
    addLoyaltyPoints: AddLoyaltyPoints;
}

export interface AddLoyaltyPointsRequest {
    loyaltyProgramId: string;
    integrationId: string;
    addLoyaltyPoints: AddLoyaltyPoints;
}

export interface CopyCampaignToApplicationsRequest {
    applicationId: number;
    campaignId: number;
    campaignCopy: CampaignCopy;
}

export interface CreateAccountCollectionRequest {
    newCollection: NewCollection;
}

export interface CreateAchievementRequest {
    applicationId: number;
    campaignId: number;
    createAchievement: CreateAchievement;
}

export interface CreateAdditionalCostRequest {
    newAdditionalCost: NewAdditionalCost;
}

export interface CreateAttributeRequest {
    newAttribute: NewAttribute;
}

export interface CreateBatchLoyaltyCardsRequest {
    loyaltyProgramId: number;
    loyaltyCardBatch: LoyaltyCardBatch;
}

export interface CreateCampaignFromTemplateRequest {
    applicationId: number;
    createTemplateCampaign: CreateTemplateCampaign;
}

export interface CreateCampaignStoreBudgetRequest {
    applicationId: number;
    campaignId: number;
    newCampaignStoreBudget: NewCampaignStoreBudget;
}

export interface CreateCollectionRequest {
    applicationId: number;
    campaignId: number;
    newCampaignCollection: NewCampaignCollection;
}

export interface CreateCouponsRequest {
    applicationId: number;
    campaignId: number;
    newCoupons: NewCoupons;
    silent?: string;
}

export interface CreateCouponsAsyncRequest {
    applicationId: number;
    campaignId: number;
    newCouponCreationJob: NewCouponCreationJob;
}

export interface CreateCouponsDeletionJobRequest {
    applicationId: number;
    campaignId: number;
    newCouponDeletionJob: NewCouponDeletionJob;
}

export interface CreateCouponsForMultipleRecipientsRequest {
    applicationId: number;
    campaignId: number;
    newCouponsForMultipleRecipients: NewCouponsForMultipleRecipients;
    silent?: string;
}

export interface CreateInviteEmailRequest {
    newInviteEmail: NewInviteEmail;
}

export interface CreateInviteV2Request {
    newInvitation: NewInvitation;
}

export interface CreatePasswordRecoveryEmailRequest {
    newPasswordEmail: NewPasswordEmail;
}

export interface CreateSessionRequest {
    loginParams: LoginParams;
}

export interface CreateStoreRequest {
    applicationId: number;
    newStore: NewStore;
}

export interface DeactivateUserByEmailRequest {
    deactivateUserRequest: DeactivateUserRequest;
}

export interface DeductLoyaltyCardPointsRequest {
    loyaltyProgramId: number;
    loyaltyCardId: string;
    deductLoyaltyPoints: DeductLoyaltyPoints;
}

export interface DeleteAccountCollectionRequest {
    collectionId: number;
}

export interface DeleteAchievementRequest {
    applicationId: number;
    campaignId: number;
    achievementId: number;
}

export interface DeleteCampaignRequest {
    applicationId: number;
    campaignId: number;
}

export interface DeleteCampaignStoreBudgetsRequest {
    applicationId: number;
    campaignId: number;
    action?: DeleteCampaignStoreBudgetsActionEnum;
    period?: DeleteCampaignStoreBudgetsPeriodEnum;
}

export interface DeleteCollectionRequest {
    applicationId: number;
    campaignId: number;
    collectionId: number;
}

export interface DeleteCouponRequest {
    applicationId: number;
    campaignId: number;
    couponId: string;
}

export interface DeleteCouponsRequest {
    applicationId: number;
    campaignId: number;
    value?: string;
    createdBefore?: Date;
    createdAfter?: Date;
    startsAfter?: Date;
    startsBefore?: Date;
    expiresAfter?: Date;
    expiresBefore?: Date;
    valid?: DeleteCouponsValidEnum;
    batchId?: string;
    usable?: DeleteCouponsUsableEnum;
    referralId?: number;
    recipientIntegrationId?: string;
    exactMatch?: boolean;
}

export interface DeleteLoyaltyCardRequest {
    loyaltyProgramId: number;
    loyaltyCardId: string;
}

export interface DeleteReferralRequest {
    applicationId: number;
    campaignId: number;
    referralId: string;
}

export interface DeleteStoreRequest {
    applicationId: number;
    storeId: string;
}

export interface DeleteUserApiRequest {
    userId: number;
}

export interface DeleteUserByEmailRequest {
    deleteUserRequest: DeleteUserRequest;
}

export interface DisconnectCampaignStoresRequest {
    applicationId: number;
    campaignId: number;
}

export interface ExportAccountCollectionItemsRequest {
    collectionId: number;
}

export interface ExportAchievementsRequest {
    applicationId: number;
    campaignId: number;
    achievementId: number;
}

export interface ExportAudiencesMembershipsRequest {
    audienceId: number;
}

export interface ExportCampaignStoreBudgetsRequest {
    applicationId: number;
    campaignId: number;
    action?: ExportCampaignStoreBudgetsActionEnum;
    period?: ExportCampaignStoreBudgetsPeriodEnum;
}

export interface ExportCampaignStoresRequest {
    applicationId: number;
    campaignId: number;
}

export interface ExportCollectionItemsRequest {
    applicationId: number;
    campaignId: number;
    collectionId: number;
}

export interface ExportCouponsRequest {
    applicationId: number;
    campaignId?: number;
    sort?: string;
    value?: string;
    createdBefore?: Date;
    createdAfter?: Date;
    valid?: ExportCouponsValidEnum;
    usable?: ExportCouponsUsableEnum;
    referralId?: number;
    recipientIntegrationId?: string;
    batchId?: string;
    exactMatch?: boolean;
    dateFormat?: ExportCouponsDateFormatEnum;
    campaignState?: ExportCouponsCampaignStateEnum;
    valuesOnly?: boolean;
}

export interface ExportCustomerSessionsRequest {
    applicationId: number;
    createdBefore?: Date;
    createdAfter?: Date;
    profileIntegrationId?: string;
    dateFormat?: ExportCustomerSessionsDateFormatEnum;
    customerSessionState?: ExportCustomerSessionsCustomerSessionStateEnum;
}

export interface ExportCustomersTiersRequest {
    loyaltyProgramId: string;
    subledgerIds?: Array<string>;
    tierNames?: Array<string>;
}

export interface ExportEffectsRequest {
    applicationId: number;
    campaignId?: number;
    createdBefore?: Date;
    createdAfter?: Date;
    dateFormat?: ExportEffectsDateFormatEnum;
}

export interface ExportLoyaltyBalanceRequest {
    loyaltyProgramId: string;
    endDate?: Date;
}

export interface ExportLoyaltyBalancesRequest {
    loyaltyProgramId: string;
    endDate?: Date;
}

export interface ExportLoyaltyCardBalancesRequest {
    loyaltyProgramId: number;
    endDate?: Date;
}

export interface ExportLoyaltyCardLedgerRequest {
    loyaltyProgramId: number;
    loyaltyCardId: string;
    rangeStart: Date;
    rangeEnd: Date;
    dateFormat?: ExportLoyaltyCardLedgerDateFormatEnum;
}

export interface ExportLoyaltyCardsRequest {
    loyaltyProgramId: number;
    batchId?: string;
    createdBefore?: Date;
    createdAfter?: Date;
    dateFormat?: ExportLoyaltyCardsDateFormatEnum;
}

export interface ExportLoyaltyLedgerRequest {
    rangeStart: Date;
    rangeEnd: Date;
    loyaltyProgramId: string;
    integrationId: string;
    dateFormat?: ExportLoyaltyLedgerDateFormatEnum;
}

export interface ExportPoolGiveawaysRequest {
    poolId: number;
    createdBefore?: Date;
    createdAfter?: Date;
}

export interface ExportReferralsRequest {
    applicationId: number;
    campaignId?: number;
    createdBefore?: Date;
    createdAfter?: Date;
    valid?: ExportReferralsValidEnum;
    usable?: ExportReferralsUsableEnum;
    batchId?: string;
    dateFormat?: ExportReferralsDateFormatEnum;
}

export interface GenerateCouponRejectionsRequest {
    sessionIntegrationId: string;
    applicationId?: number;
    language?: string;
    couponCode?: string;
}

export interface GetAccessLogsWithoutTotalCountRequest {
    applicationId: number;
    rangeStart: Date;
    rangeEnd: Date;
    path?: string;
    method?: GetAccessLogsWithoutTotalCountMethodEnum;
    status?: GetAccessLogsWithoutTotalCountStatusEnum;
    pageSize?: number;
    skip?: number;
    sort?: string;
}

export interface GetAccountRequest {
    accountId: number;
}

export interface GetAccountAnalyticsRequest {
    accountId: number;
}

export interface GetAccountCollectionRequest {
    collectionId: number;
}

export interface GetAchievementRequest {
    applicationId: number;
    campaignId: number;
    achievementId: number;
}

export interface GetAdditionalCostRequest {
    additionalCostId: number;
}

export interface GetAdditionalCostsRequest {
    pageSize?: number;
    skip?: number;
    sort?: string;
}

export interface GetApplicationRequest {
    applicationId: number;
}

export interface GetApplicationApiHealthRequest {
    applicationId: number;
}

export interface GetApplicationCustomerRequest {
    applicationId: number;
    customerId: number;
}

export interface GetApplicationCustomerFriendsRequest {
    applicationId: number;
    integrationId: string;
    pageSize?: number;
    skip?: number;
    sort?: string;
    withTotalResultSize?: boolean;
}

export interface GetApplicationCustomersRequest {
    applicationId: number;
    integrationId?: string;
    pageSize?: number;
    skip?: number;
    withTotalResultSize?: boolean;
}

export interface GetApplicationCustomersByAttributesRequest {
    applicationId: number;
    customerProfileSearchQuery: CustomerProfileSearchQuery;
    pageSize?: number;
    skip?: number;
    withTotalResultSize?: boolean;
}

export interface GetApplicationEventTypesRequest {
    applicationId: number;
    pageSize?: number;
    skip?: number;
    sort?: string;
}

export interface GetApplicationEventsWithoutTotalCountRequest {
    applicationId: number;
    pageSize?: number;
    skip?: number;
    sort?: string;
    type?: string;
    createdBefore?: Date;
    createdAfter?: Date;
    session?: string;
    profile?: string;
    customerName?: string;
    customerEmail?: string;
    couponCode?: string;
    referralCode?: string;
    ruleQuery?: string;
    campaignQuery?: string;
    effectType?: string;
}

export interface GetApplicationSessionRequest {
    applicationId: number;
    sessionId: number;
}

export interface GetApplicationSessionsRequest {
    applicationId: number;
    pageSize?: number;
    skip?: number;
    sort?: string;
    profile?: string;
    state?: GetApplicationSessionsStateEnum;
    createdBefore?: Date;
    createdAfter?: Date;
    coupon?: string;
    referral?: string;
    integrationId?: string;
    storeIntegrationId?: string;
}

export interface GetApplicationsRequest {
    pageSize?: number;
    skip?: number;
    sort?: string;
}

export interface GetAttributeRequest {
    attributeId: number;
}

export interface GetAttributesRequest {
    pageSize?: number;
    skip?: number;
    sort?: string;
    entity?: string;
    applicationIds?: string;
    type?: string;
    kind?: GetAttributesKindEnum;
    search?: string;
}

export interface GetAudienceMembershipsRequest {
    audienceId: number;
    pageSize?: number;
    skip?: number;
    sort?: string;
    profileQuery?: string;
}

export interface GetAudiencesRequest {
    pageSize?: number;
    skip?: number;
    sort?: string;
    withTotalResultSize?: boolean;
}

export interface GetAudiencesAnalyticsRequest {
    audienceIds: string;
    sort?: string;
}

export interface GetCampaignRequest {
    applicationId: number;
    campaignId: number;
}

export interface GetCampaignAnalyticsRequest {
    applicationId: number;
    campaignId: number;
    rangeStart: Date;
    rangeEnd: Date;
    granularity?: GetCampaignAnalyticsGranularityEnum;
}

export interface GetCampaignByAttributesRequest {
    applicationId: number;
    campaignSearch: CampaignSearch;
    pageSize?: number;
    skip?: number;
    sort?: string;
    campaignState?: GetCampaignByAttributesCampaignStateEnum;
}

export interface GetCampaignGroupRequest {
    campaignGroupId: number;
}

export interface GetCampaignGroupsRequest {
    pageSize?: number;
    skip?: number;
    sort?: string;
}

export interface GetCampaignTemplatesRequest {
    pageSize?: number;
    skip?: number;
    sort?: string;
    state?: GetCampaignTemplatesStateEnum;
    name?: string;
    tags?: string;
    userId?: number;
}

export interface GetCampaignsRequest {
    applicationId: number;
    pageSize?: number;
    skip?: number;
    sort?: string;
    campaignState?: GetCampaignsCampaignStateEnum;
    name?: string;
    tags?: string;
    createdBefore?: Date;
    createdAfter?: Date;
    startBefore?: Date;
    startAfter?: Date;
    endBefore?: Date;
    endAfter?: Date;
    campaignGroupId?: number;
    templateId?: number;
    storeId?: number;
}

export interface GetChangesRequest {
    pageSize?: number;
    skip?: number;
    sort?: string;
    applicationId?: number;
    entityPath?: string;
    userId?: number;
    createdBefore?: Date;
    createdAfter?: Date;
    withTotalResultSize?: boolean;
    managementKeyId?: number;
    includeOld?: boolean;
}

export interface GetCollectionRequest {
    applicationId: number;
    campaignId: number;
    collectionId: number;
}

export interface GetCollectionItemsRequest {
    collectionId: number;
    pageSize?: number;
    skip?: number;
}

export interface GetCouponsWithoutTotalCountRequest {
    applicationId: number;
    campaignId: number;
    pageSize?: number;
    skip?: number;
    sort?: string;
    value?: string;
    createdBefore?: Date;
    createdAfter?: Date;
    valid?: GetCouponsWithoutTotalCountValidEnum;
    usable?: GetCouponsWithoutTotalCountUsableEnum;
    redeemed?: GetCouponsWithoutTotalCountRedeemedEnum;
    referralId?: number;
    recipientIntegrationId?: string;
    batchId?: string;
    exactMatch?: boolean;
    expiresBefore?: Date;
    expiresAfter?: Date;
    startsBefore?: Date;
    startsAfter?: Date;
    valuesOnly?: boolean;
}

export interface GetCustomerActivityReportRequest {
    rangeStart: Date;
    rangeEnd: Date;
    applicationId: number;
    customerId: number;
    pageSize?: number;
    skip?: number;
}

export interface GetCustomerActivityReportsWithoutTotalCountRequest {
    rangeStart: Date;
    rangeEnd: Date;
    applicationId: number;
    pageSize?: number;
    skip?: number;
    sort?: string;
    name?: string;
    integrationId?: string;
    campaignName?: string;
    advocateName?: string;
}

export interface GetCustomerAnalyticsRequest {
    applicationId: number;
    customerId: number;
    pageSize?: number;
    skip?: number;
    sort?: string;
}

export interface GetCustomerProfileRequest {
    customerId: number;
}

export interface GetCustomerProfileAchievementProgressRequest {
    applicationId: number;
    integrationId: string;
    pageSize?: number;
    skip?: number;
    achievementId?: number;
    title?: string;
}

export interface GetCustomerProfilesRequest {
    pageSize?: number;
    skip?: number;
    sandbox?: boolean;
}

export interface GetCustomersByAttributesRequest {
    customerProfileSearchQuery: CustomerProfileSearchQuery;
    pageSize?: number;
    skip?: number;
    sandbox?: boolean;
}

export interface GetDashboardStatisticsRequest {
    loyaltyProgramId: number;
    rangeStart: Date;
    rangeEnd: Date;
    subledgerId?: string;
}

export interface GetEventTypesRequest {
    name?: string;
    includeOldVersions?: boolean;
    pageSize?: number;
    skip?: number;
    sort?: string;
}

export interface GetExportsRequest {
    pageSize?: number;
    skip?: number;
    applicationId?: number;
    campaignId?: number;
    entity?: GetExportsEntityEnum;
}

export interface GetLoyaltyCardRequest {
    loyaltyProgramId: number;
    loyaltyCardId: string;
}

export interface GetLoyaltyCardTransactionLogsRequest {
    loyaltyProgramId: number;
    loyaltyCardId: string;
    startDate?: Date;
    endDate?: Date;
    pageSize?: number;
    skip?: number;
    subledgerId?: string;
    customerSessionIDs?: Array<string>;
    transactionUUIDs?: Array<string>;
}

export interface GetLoyaltyCardsRequest {
    loyaltyProgramId: number;
    pageSize?: number;
    skip?: number;
    sort?: string;
    identifier?: string;
    profileId?: number;
    batchId?: string;
}

export interface GetLoyaltyLedgerBalancesRequest {
    loyaltyProgramId: number;
    integrationId: string;
    endDate?: Date;
    subledgerId?: string;
    includeTiers?: boolean;
    includeProjectedTier?: boolean;
}

export interface GetLoyaltyPointsRequest {
    loyaltyProgramId: string;
    integrationId: string;
}

export interface GetLoyaltyProgramRequest {
    loyaltyProgramId: number;
}

export interface GetLoyaltyProgramProfileLedgerTransactionsRequest {
    loyaltyProgramId: number;
    integrationId: string;
    customerSessionIDs?: Array<string>;
    transactionUUIDs?: Array<string>;
    subledgerId?: string;
    loyaltyTransactionType?: GetLoyaltyProgramProfileLedgerTransactionsLoyaltyTransactionTypeEnum;
    startDate?: Date;
    endDate?: Date;
    pageSize?: number;
    skip?: number;
    awaitsActivation?: boolean;
}

export interface GetLoyaltyProgramTransactionsRequest {
    loyaltyProgramId: number;
    loyaltyTransactionType?: GetLoyaltyProgramTransactionsLoyaltyTransactionTypeEnum;
    subledgerId?: string;
    customerSessionIDs?: Array<string>;
    transactionUUIDs?: Array<string>;
    startDate?: Date;
    endDate?: Date;
    pageSize?: number;
    skip?: number;
    awaitsActivation?: boolean;
}

export interface GetLoyaltyStatisticsRequest {
    loyaltyProgramId: number;
}

export interface GetMessageLogsRequest {
    entityType: GetMessageLogsEntityTypeEnum;
    messageID?: string;
    changeType?: GetMessageLogsChangeTypeEnum;
    notificationIDs?: string;
    createdBefore?: Date;
    createdAfter?: Date;
    cursor?: string;
    period?: GetMessageLogsPeriodEnum;
    isSuccessful?: boolean;
    applicationId?: number;
    campaignId?: number;
    loyaltyProgramId?: number;
    responseCode?: number;
    webhookIDs?: string;
}

export interface GetReferralsWithoutTotalCountRequest {
    applicationId: number;
    campaignId: number;
    pageSize?: number;
    skip?: number;
    sort?: string;
    code?: string;
    createdBefore?: Date;
    createdAfter?: Date;
    valid?: GetReferralsWithoutTotalCountValidEnum;
    usable?: GetReferralsWithoutTotalCountUsableEnum;
    advocate?: string;
}

export interface GetRoleV2Request {
    roleId: number;
}

export interface GetRulesetRequest {
    applicationId: number;
    campaignId: number;
    rulesetId: number;
}

export interface GetRulesetsRequest {
    applicationId: number;
    campaignId: number;
    pageSize?: number;
    skip?: number;
    sort?: string;
}

export interface GetStoreRequest {
    applicationId: number;
    storeId: string;
}

export interface GetUserRequest {
    userId: number;
}

export interface GetUsersRequest {
    pageSize?: number;
    skip?: number;
    sort?: string;
}

export interface GetWebhookRequest {
    webhookId: number;
}

export interface GetWebhooksRequest {
    applicationIds?: string;
    sort?: string;
    pageSize?: number;
    skip?: number;
    creationType?: GetWebhooksCreationTypeEnum;
    visibility?: GetWebhooksVisibilityEnum;
    outgoingIntegrationsTypeId?: number;
    title?: string;
}

export interface ImportAccountCollectionRequest {
    collectionId: number;
    upFile?: string;
}

export interface ImportAllowedListRequest {
    attributeId: number;
    upFile?: string;
}

export interface ImportAudiencesMembershipsRequest {
    audienceId: number;
    upFile?: string;
}

export interface ImportCampaignStoreBudgetRequest {
    applicationId: number;
    campaignId: number;
    action?: ImportCampaignStoreBudgetActionEnum;
    period?: ImportCampaignStoreBudgetPeriodEnum;
    upFile?: string;
}

export interface ImportCampaignStoresRequest {
    applicationId: number;
    campaignId: number;
    upFile?: string;
}

export interface ImportCollectionRequest {
    applicationId: number;
    campaignId: number;
    collectionId: number;
    upFile?: string;
}

export interface ImportCouponsRequest {
    applicationId: number;
    campaignId: number;
    skipDuplicates?: boolean;
    upFile?: string;
}

export interface ImportLoyaltyCardsRequest {
    loyaltyProgramId: number;
    upFile?: string;
}

export interface ImportLoyaltyCustomersTiersRequest {
    loyaltyProgramId: number;
    upFile?: string;
}

export interface ImportLoyaltyPointsRequest {
    loyaltyProgramId: number;
    notificationsEnabled?: boolean;
    upFile?: string;
}

export interface ImportPoolGiveawaysRequest {
    poolId: number;
    upFile?: string;
}

export interface ImportReferralsRequest {
    applicationId: number;
    campaignId: number;
    upFile?: string;
}

export interface InviteUserExternalRequest {
    newExternalInvitation: NewExternalInvitation;
}

export interface ListAccountCollectionsRequest {
    pageSize?: number;
    skip?: number;
    sort?: string;
    withTotalResultSize?: boolean;
    name?: string;
}

export interface ListAchievementsRequest {
    applicationId: number;
    campaignId: number;
    pageSize?: number;
    skip?: number;
    title?: string;
}

export interface ListCampaignStoreBudgetLimitsRequest {
    applicationId: number;
    campaignId: number;
    action?: ListCampaignStoreBudgetLimitsActionEnum;
    period?: ListCampaignStoreBudgetLimitsPeriodEnum;
}

export interface ListCatalogItemsRequest {
    catalogId: number;
    pageSize?: number;
    skip?: number;
    withTotalResultSize?: boolean;
    sku?: Array<string>;
    productNames?: Array<string>;
}

export interface ListCollectionsRequest {
    applicationId: number;
    campaignId: number;
    pageSize?: number;
    skip?: number;
    sort?: string;
    withTotalResultSize?: boolean;
    name?: string;
}

export interface ListCollectionsInApplicationRequest {
    applicationId: number;
    pageSize?: number;
    skip?: number;
    sort?: string;
    withTotalResultSize?: boolean;
    name?: string;
}

export interface ListStoresRequest {
    applicationId: number;
    pageSize?: number;
    skip?: number;
    sort?: string;
    withTotalResultSize?: boolean;
    campaignId?: number;
    name?: string;
    integrationId?: string;
    query?: string;
}

export interface RemoveLoyaltyPointsRequest {
    loyaltyProgramId: string;
    integrationId: string;
    deductLoyaltyPoints: DeductLoyaltyPoints;
}

export interface ResetPasswordRequest {
    newPassword: NewPassword;
}

export interface ScimCreateGroupRequest {
    scimBaseGroup: ScimBaseGroup;
}

export interface ScimCreateUserRequest {
    scimNewUser: ScimNewUser;
}

export interface ScimDeleteGroupRequest {
    groupId: number;
}

export interface ScimDeleteUserRequest {
    userId: number;
}

export interface ScimGetGroupRequest {
    groupId: number;
}

export interface ScimGetUserRequest {
    userId: number;
}

export interface ScimPatchGroupRequest {
    groupId: number;
    scimPatchRequest: ScimPatchRequest;
}

export interface ScimPatchUserRequest {
    userId: number;
    scimPatchRequest: ScimPatchRequest;
}

export interface ScimReplaceGroupAttributesRequest {
    groupId: number;
    scimBaseGroup: ScimBaseGroup;
}

export interface ScimReplaceUserAttributesRequest {
    userId: number;
    scimNewUser: ScimNewUser;
}

export interface SearchCouponsAdvancedApplicationWideWithoutTotalCountRequest {
    applicationId: number;
    body: object;
    pageSize?: number;
    skip?: number;
    sort?: string;
    value?: string;
    createdBefore?: Date;
    createdAfter?: Date;
    valid?: SearchCouponsAdvancedApplicationWideWithoutTotalCountValidEnum;
    usable?: SearchCouponsAdvancedApplicationWideWithoutTotalCountUsableEnum;
    referralId?: number;
    recipientIntegrationId?: string;
    batchId?: string;
    exactMatch?: boolean;
    campaignState?: SearchCouponsAdvancedApplicationWideWithoutTotalCountCampaignStateEnum;
}

export interface SearchCouponsAdvancedWithoutTotalCountRequest {
    applicationId: number;
    campaignId: number;
    body: object;
    pageSize?: number;
    skip?: number;
    sort?: string;
    value?: string;
    createdBefore?: Date;
    createdAfter?: Date;
    valid?: SearchCouponsAdvancedWithoutTotalCountValidEnum;
    usable?: SearchCouponsAdvancedWithoutTotalCountUsableEnum;
    referralId?: number;
    recipientIntegrationId?: string;
    exactMatch?: boolean;
    batchId?: string;
}

export interface SummarizeCampaignStoreBudgetRequest {
    applicationId: number;
    campaignId: number;
}

export interface TransferLoyaltyCardRequest {
    loyaltyProgramId: number;
    loyaltyCardId: string;
    transferLoyaltyCard: TransferLoyaltyCard;
}

export interface UpdateAccountCollectionRequest {
    collectionId: number;
    updateCollection: UpdateCollection;
}

export interface UpdateAchievementRequest {
    applicationId: number;
    campaignId: number;
    achievementId: number;
    updateAchievement: UpdateAchievement;
}

export interface UpdateAdditionalCostRequest {
    additionalCostId: number;
    newAdditionalCost: NewAdditionalCost;
}

export interface UpdateAttributeRequest {
    attributeId: number;
    newAttribute: NewAttribute;
}

export interface UpdateCampaignRequest {
    applicationId: number;
    campaignId: number;
    updateCampaign: UpdateCampaign;
}

export interface UpdateCollectionRequest {
    applicationId: number;
    campaignId: number;
    collectionId: number;
    updateCampaignCollection: UpdateCampaignCollection;
}

export interface UpdateCouponRequest {
    applicationId: number;
    campaignId: number;
    couponId: string;
    updateCoupon: UpdateCoupon;
}

export interface UpdateCouponBatchRequest {
    applicationId: number;
    campaignId: number;
    updateCouponBatch: UpdateCouponBatch;
}

export interface UpdateLoyaltyCardRequest {
    loyaltyProgramId: number;
    loyaltyCardId: string;
    updateLoyaltyCard: UpdateLoyaltyCard;
}

export interface UpdateReferralRequest {
    applicationId: number;
    campaignId: number;
    referralId: string;
    updateReferral: UpdateReferral;
}

export interface UpdateRoleV2Request {
    roleId: number;
    roleV2Base: RoleV2Base;
}

export interface UpdateStoreRequest {
    applicationId: number;
    storeId: string;
    newStore: NewStore;
}

export interface UpdateUserRequest {
    userId: number;
    updateUser: UpdateUser;
}

/**
 * 
 */
export class ManagementApi extends runtime.BaseAPI {

    /**
     * Enable a [disabled user](https://docs.talon.one/docs/product/account/account-settings/managing-users#disabling-a-user) by their email address. 
     * Enable user by email address
     */
    async activateUserByEmailRaw(requestParameters: ActivateUserByEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['activateUserRequest'] == null) {
            throw new runtime.RequiredError(
                'activateUserRequest',
                'Required parameter "activateUserRequest" was null or undefined when calling activateUserByEmail().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/users/activate`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ActivateUserRequestToJSON(requestParameters['activateUserRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Enable a [disabled user](https://docs.talon.one/docs/product/account/account-settings/managing-users#disabling-a-user) by their email address. 
     * Enable user by email address
     */
    async activateUserByEmail(requestParameters: ActivateUserByEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.activateUserByEmailRaw(requestParameters, initOverrides);
    }

    /**
     * Add points to the given loyalty card in the specified card-based loyalty program. 
     * Add points to card
     */
    async addLoyaltyCardPointsRaw(requestParameters: AddLoyaltyCardPointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling addLoyaltyCardPoints().'
            );
        }

        if (requestParameters['loyaltyCardId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyCardId',
                'Required parameter "loyaltyCardId" was null or undefined when calling addLoyaltyCardPoints().'
            );
        }

        if (requestParameters['addLoyaltyPoints'] == null) {
            throw new runtime.RequiredError(
                'addLoyaltyPoints',
                'Required parameter "addLoyaltyPoints" was null or undefined when calling addLoyaltyCardPoints().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/cards/{loyaltyCardId}/add_points`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));
        urlPath = urlPath.replace(`{${"loyaltyCardId"}}`, encodeURIComponent(String(requestParameters['loyaltyCardId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AddLoyaltyPointsToJSON(requestParameters['addLoyaltyPoints']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add points to the given loyalty card in the specified card-based loyalty program. 
     * Add points to card
     */
    async addLoyaltyCardPoints(requestParameters: AddLoyaltyCardPointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addLoyaltyCardPointsRaw(requestParameters, initOverrides);
    }

    /**
     * Add points in the specified loyalty program for the given customer.  To get the `integrationId` of the profile from a `sessionId`, use the [Update customer session](https://docs.talon.one/integration-api#operation/updateCustomerSessionV2) endpoint. 
     * Add points to customer profile
     */
    async addLoyaltyPointsRaw(requestParameters: AddLoyaltyPointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling addLoyaltyPoints().'
            );
        }

        if (requestParameters['integrationId'] == null) {
            throw new runtime.RequiredError(
                'integrationId',
                'Required parameter "integrationId" was null or undefined when calling addLoyaltyPoints().'
            );
        }

        if (requestParameters['addLoyaltyPoints'] == null) {
            throw new runtime.RequiredError(
                'addLoyaltyPoints',
                'Required parameter "addLoyaltyPoints" was null or undefined when calling addLoyaltyPoints().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/profile/{integrationId}/add_points`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));
        urlPath = urlPath.replace(`{${"integrationId"}}`, encodeURIComponent(String(requestParameters['integrationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AddLoyaltyPointsToJSON(requestParameters['addLoyaltyPoints']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add points in the specified loyalty program for the given customer.  To get the `integrationId` of the profile from a `sessionId`, use the [Update customer session](https://docs.talon.one/integration-api#operation/updateCustomerSessionV2) endpoint. 
     * Add points to customer profile
     */
    async addLoyaltyPoints(requestParameters: AddLoyaltyPointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addLoyaltyPointsRaw(requestParameters, initOverrides);
    }

    /**
     * Copy the campaign into all specified Applications.
     * Copy the campaign into the specified Application
     */
    async copyCampaignToApplicationsRaw(requestParameters: CopyCampaignToApplicationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCampaigns200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling copyCampaignToApplications().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling copyCampaignToApplications().'
            );
        }

        if (requestParameters['campaignCopy'] == null) {
            throw new runtime.RequiredError(
                'campaignCopy',
                'Required parameter "campaignCopy" was null or undefined when calling copyCampaignToApplications().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/copy`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CampaignCopyToJSON(requestParameters['campaignCopy']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetCampaigns200ResponseFromJSON(jsonValue));
    }

    /**
     * Copy the campaign into all specified Applications.
     * Copy the campaign into the specified Application
     */
    async copyCampaignToApplications(requestParameters: CopyCampaignToApplicationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCampaigns200Response> {
        const response = await this.copyCampaignToApplicationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an account-level collection.
     * Create account-level collection
     */
    async createAccountCollectionRaw(requestParameters: CreateAccountCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Collection>> {
        if (requestParameters['newCollection'] == null) {
            throw new runtime.RequiredError(
                'newCollection',
                'Required parameter "newCollection" was null or undefined when calling createAccountCollection().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/collections`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewCollectionToJSON(requestParameters['newCollection']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CollectionFromJSON(jsonValue));
    }

    /**
     * Create an account-level collection.
     * Create account-level collection
     */
    async createAccountCollection(requestParameters: CreateAccountCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Collection> {
        const response = await this.createAccountCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new achievement in a specific campaign.
     * Create achievement
     */
    async createAchievementRaw(requestParameters: CreateAchievementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Achievement>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling createAchievement().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling createAchievement().'
            );
        }

        if (requestParameters['createAchievement'] == null) {
            throw new runtime.RequiredError(
                'createAchievement',
                'Required parameter "createAchievement" was null or undefined when calling createAchievement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/achievements`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateAchievementToJSON(requestParameters['createAchievement']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AchievementFromJSON(jsonValue));
    }

    /**
     * Create a new achievement in a specific campaign.
     * Create achievement
     */
    async createAchievement(requestParameters: CreateAchievementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Achievement> {
        const response = await this.createAchievementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an [additional cost](https://docs.talon.one/docs/product/account/dev-tools/managing-additional-costs).  These additional costs are shared across all applications in your account, and are never required. 
     * Create additional cost
     */
    async createAdditionalCostRaw(requestParameters: CreateAdditionalCostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountAdditionalCost>> {
        if (requestParameters['newAdditionalCost'] == null) {
            throw new runtime.RequiredError(
                'newAdditionalCost',
                'Required parameter "newAdditionalCost" was null or undefined when calling createAdditionalCost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/additional_costs`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewAdditionalCostToJSON(requestParameters['newAdditionalCost']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountAdditionalCostFromJSON(jsonValue));
    }

    /**
     * Create an [additional cost](https://docs.talon.one/docs/product/account/dev-tools/managing-additional-costs).  These additional costs are shared across all applications in your account, and are never required. 
     * Create additional cost
     */
    async createAdditionalCost(requestParameters: CreateAdditionalCostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountAdditionalCost> {
        const response = await this.createAdditionalCostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a _custom attribute_ in this account. [Custom attributes](https://docs.talon.one/docs/dev/concepts/attributes) allow you to add data to Talon.One domain entities like campaigns, coupons, customers and so on.  These attributes can then be given values when creating/updating these entities, and these values can be used in your campaign rules.  For example, you could define a `zipCode` field for customer sessions, and add a rule to your campaign that only allows certain ZIP codes.  These attributes are shared across all Applications in your account and are never required. 
     * Create custom attribute
     */
    async createAttributeRaw(requestParameters: CreateAttributeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Attribute>> {
        if (requestParameters['newAttribute'] == null) {
            throw new runtime.RequiredError(
                'newAttribute',
                'Required parameter "newAttribute" was null or undefined when calling createAttribute().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/attributes`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewAttributeToJSON(requestParameters['newAttribute']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AttributeFromJSON(jsonValue));
    }

    /**
     * Create a _custom attribute_ in this account. [Custom attributes](https://docs.talon.one/docs/dev/concepts/attributes) allow you to add data to Talon.One domain entities like campaigns, coupons, customers and so on.  These attributes can then be given values when creating/updating these entities, and these values can be used in your campaign rules.  For example, you could define a `zipCode` field for customer sessions, and add a rule to your campaign that only allows certain ZIP codes.  These attributes are shared across all Applications in your account and are never required. 
     * Create custom attribute
     */
    async createAttribute(requestParameters: CreateAttributeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Attribute> {
        const response = await this.createAttributeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a batch of loyalty cards in a specified [card-based loyalty program](https://docs.talon.one/docs/product/loyalty-programs/overview#loyalty-program-types).  Customers can use loyalty cards to collect and spend loyalty points.  **Important:**  - The specified card-based loyalty program must have a defined card code format that is used to generate the loyalty card codes. - Trying to create more than 20,000 loyalty cards in a single request returns an error message with a `400` status code. 
     * Create loyalty cards
     */
    async createBatchLoyaltyCardsRaw(requestParameters: CreateBatchLoyaltyCardsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoyaltyCardBatchResponse>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling createBatchLoyaltyCards().'
            );
        }

        if (requestParameters['loyaltyCardBatch'] == null) {
            throw new runtime.RequiredError(
                'loyaltyCardBatch',
                'Required parameter "loyaltyCardBatch" was null or undefined when calling createBatchLoyaltyCards().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/cards/batch`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoyaltyCardBatchToJSON(requestParameters['loyaltyCardBatch']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LoyaltyCardBatchResponseFromJSON(jsonValue));
    }

    /**
     * Create a batch of loyalty cards in a specified [card-based loyalty program](https://docs.talon.one/docs/product/loyalty-programs/overview#loyalty-program-types).  Customers can use loyalty cards to collect and spend loyalty points.  **Important:**  - The specified card-based loyalty program must have a defined card code format that is used to generate the loyalty card codes. - Trying to create more than 20,000 loyalty cards in a single request returns an error message with a `400` status code. 
     * Create loyalty cards
     */
    async createBatchLoyaltyCards(requestParameters: CreateBatchLoyaltyCardsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoyaltyCardBatchResponse> {
        const response = await this.createBatchLoyaltyCardsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use the campaign template referenced in the request body to create a new campaign in one of the connected Applications.  If the template was created from a campaign with rules referencing [campaign collections](https://docs.talon.one/docs/product/campaigns/managing-collections), the corresponding collections for the new campaign are created automatically. 
     * Create campaign from campaign template
     */
    async createCampaignFromTemplateRaw(requestParameters: CreateCampaignFromTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateTemplateCampaignResponse>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling createCampaignFromTemplate().'
            );
        }

        if (requestParameters['createTemplateCampaign'] == null) {
            throw new runtime.RequiredError(
                'createTemplateCampaign',
                'Required parameter "createTemplateCampaign" was null or undefined when calling createCampaignFromTemplate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/create_campaign_from_template`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateTemplateCampaignToJSON(requestParameters['createTemplateCampaign']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateTemplateCampaignResponseFromJSON(jsonValue));
    }

    /**
     * Use the campaign template referenced in the request body to create a new campaign in one of the connected Applications.  If the template was created from a campaign with rules referencing [campaign collections](https://docs.talon.one/docs/product/campaigns/managing-collections), the corresponding collections for the new campaign are created automatically. 
     * Create campaign from campaign template
     */
    async createCampaignFromTemplate(requestParameters: CreateCampaignFromTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateTemplateCampaignResponse> {
        const response = await this.createCampaignFromTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new store budget for a given campaign.
     * Create campaign store budget
     */
    async createCampaignStoreBudgetRaw(requestParameters: CreateCampaignStoreBudgetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling createCampaignStoreBudget().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling createCampaignStoreBudget().'
            );
        }

        if (requestParameters['newCampaignStoreBudget'] == null) {
            throw new runtime.RequiredError(
                'newCampaignStoreBudget',
                'Required parameter "newCampaignStoreBudget" was null or undefined when calling createCampaignStoreBudget().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/stores/budgets`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewCampaignStoreBudgetToJSON(requestParameters['newCampaignStoreBudget']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a new store budget for a given campaign.
     * Create campaign store budget
     */
    async createCampaignStoreBudget(requestParameters: CreateCampaignStoreBudgetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createCampaignStoreBudgetRaw(requestParameters, initOverrides);
    }

    /**
     * Create a campaign-level collection in a given campaign.
     * Create campaign-level collection
     */
    async createCollectionRaw(requestParameters: CreateCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Collection>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling createCollection().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling createCollection().'
            );
        }

        if (requestParameters['newCampaignCollection'] == null) {
            throw new runtime.RequiredError(
                'newCampaignCollection',
                'Required parameter "newCampaignCollection" was null or undefined when calling createCollection().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/collections`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewCampaignCollectionToJSON(requestParameters['newCampaignCollection']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CollectionFromJSON(jsonValue));
    }

    /**
     * Create a campaign-level collection in a given campaign.
     * Create campaign-level collection
     */
    async createCollection(requestParameters: CreateCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Collection> {
        const response = await this.createCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create coupons according to some pattern. Up to 20.000 coupons can be created without a unique prefix. When a unique prefix is provided, up to 200.000 coupons can be created.
     * Create coupons
     */
    async createCouponsRaw(requestParameters: CreateCouponsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateCoupons200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling createCoupons().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling createCoupons().'
            );
        }

        if (requestParameters['newCoupons'] == null) {
            throw new runtime.RequiredError(
                'newCoupons',
                'Required parameter "newCoupons" was null or undefined when calling createCoupons().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['silent'] != null) {
            queryParameters['silent'] = requestParameters['silent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/coupons`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewCouponsToJSON(requestParameters['newCoupons']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateCoupons200ResponseFromJSON(jsonValue));
    }

    /**
     * Create coupons according to some pattern. Up to 20.000 coupons can be created without a unique prefix. When a unique prefix is provided, up to 200.000 coupons can be created.
     * Create coupons
     */
    async createCoupons(requestParameters: CreateCouponsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateCoupons200Response | null | undefined > {
        const response = await this.createCouponsRaw(requestParameters, initOverrides);
        switch (response.raw.status) {
            case 200:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Create up to 5,000,000 coupons asynchronously. You should typically use this enpdoint when you create at least 20,001 coupons. You receive an email when the creation is complete.  If you want to create less than 20,001 coupons, you can use the [Create coupons](https://docs.talon.one/management-api#tag/Coupons/operation/createCoupons) endpoint. 
     * Create coupons asynchronously
     */
    async createCouponsAsyncRaw(requestParameters: CreateCouponsAsyncRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AsyncCouponCreationResponse>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling createCouponsAsync().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling createCouponsAsync().'
            );
        }

        if (requestParameters['newCouponCreationJob'] == null) {
            throw new runtime.RequiredError(
                'newCouponCreationJob',
                'Required parameter "newCouponCreationJob" was null or undefined when calling createCouponsAsync().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_async`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewCouponCreationJobToJSON(requestParameters['newCouponCreationJob']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AsyncCouponCreationResponseFromJSON(jsonValue));
    }

    /**
     * Create up to 5,000,000 coupons asynchronously. You should typically use this enpdoint when you create at least 20,001 coupons. You receive an email when the creation is complete.  If you want to create less than 20,001 coupons, you can use the [Create coupons](https://docs.talon.one/management-api#tag/Coupons/operation/createCoupons) endpoint. 
     * Create coupons asynchronously
     */
    async createCouponsAsync(requestParameters: CreateCouponsAsyncRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AsyncCouponCreationResponse> {
        const response = await this.createCouponsAsyncRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint handles creating a job to delete coupons asynchronously. 
     * Creates a coupon deletion job
     */
    async createCouponsDeletionJobRaw(requestParameters: CreateCouponsDeletionJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AsyncCouponDeletionJobResponse>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling createCouponsDeletionJob().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling createCouponsDeletionJob().'
            );
        }

        if (requestParameters['newCouponDeletionJob'] == null) {
            throw new runtime.RequiredError(
                'newCouponDeletionJob',
                'Required parameter "newCouponDeletionJob" was null or undefined when calling createCouponsDeletionJob().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_deletion_jobs`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewCouponDeletionJobToJSON(requestParameters['newCouponDeletionJob']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AsyncCouponDeletionJobResponseFromJSON(jsonValue));
    }

    /**
     * This endpoint handles creating a job to delete coupons asynchronously. 
     * Creates a coupon deletion job
     */
    async createCouponsDeletionJob(requestParameters: CreateCouponsDeletionJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AsyncCouponDeletionJobResponse> {
        const response = await this.createCouponsDeletionJobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create coupons according to some pattern for up to 1000 recipients.
     * Create coupons for multiple recipients
     */
    async createCouponsForMultipleRecipientsRaw(requestParameters: CreateCouponsForMultipleRecipientsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateCoupons200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling createCouponsForMultipleRecipients().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling createCouponsForMultipleRecipients().'
            );
        }

        if (requestParameters['newCouponsForMultipleRecipients'] == null) {
            throw new runtime.RequiredError(
                'newCouponsForMultipleRecipients',
                'Required parameter "newCouponsForMultipleRecipients" was null or undefined when calling createCouponsForMultipleRecipients().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['silent'] != null) {
            queryParameters['silent'] = requestParameters['silent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_with_recipients`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewCouponsForMultipleRecipientsToJSON(requestParameters['newCouponsForMultipleRecipients']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateCoupons200ResponseFromJSON(jsonValue));
    }

    /**
     * Create coupons according to some pattern for up to 1000 recipients.
     * Create coupons for multiple recipients
     */
    async createCouponsForMultipleRecipients(requestParameters: CreateCouponsForMultipleRecipientsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateCoupons200Response | null | undefined > {
        const response = await this.createCouponsForMultipleRecipientsRaw(requestParameters, initOverrides);
        switch (response.raw.status) {
            case 200:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Resend an email invitation to an existing user.  **Note:** The invitation token is valid for 24 hours after the email has been sent. 
     * Resend invitation email
     */
    async createInviteEmailRaw(requestParameters: CreateInviteEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NewInviteEmail>> {
        if (requestParameters['newInviteEmail'] == null) {
            throw new runtime.RequiredError(
                'newInviteEmail',
                'Required parameter "newInviteEmail" was null or undefined when calling createInviteEmail().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/invite_emails`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewInviteEmailToJSON(requestParameters['newInviteEmail']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NewInviteEmailFromJSON(jsonValue));
    }

    /**
     * Resend an email invitation to an existing user.  **Note:** The invitation token is valid for 24 hours after the email has been sent. 
     * Resend invitation email
     */
    async createInviteEmail(requestParameters: CreateInviteEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NewInviteEmail> {
        const response = await this.createInviteEmailRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new user in the account and send an invitation to their email address.  **Note**: The invitation token is valid for 24 hours after the email has been sent. You can resend an invitation to a user with the [Resend invitation email](https://docs.talon.one/management-api#tag/Accounts-and-users/operation/createInviteEmail) endpoint. 
     * Invite user
     */
    async createInviteV2Raw(requestParameters: CreateInviteV2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<User>> {
        if (requestParameters['newInvitation'] == null) {
            throw new runtime.RequiredError(
                'newInvitation',
                'Required parameter "newInvitation" was null or undefined when calling createInviteV2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v2/invites`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewInvitationToJSON(requestParameters['newInvitation']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * Create a new user in the account and send an invitation to their email address.  **Note**: The invitation token is valid for 24 hours after the email has been sent. You can resend an invitation to a user with the [Resend invitation email](https://docs.talon.one/management-api#tag/Accounts-and-users/operation/createInviteEmail) endpoint. 
     * Invite user
     */
    async createInviteV2(requestParameters: CreateInviteV2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<User> {
        const response = await this.createInviteV2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Send an email with a password recovery link to the email address of an existing account.  **Note:** The password recovery link expires 30 minutes after this endpoint is triggered. 
     * Request a password reset
     */
    async createPasswordRecoveryEmailRaw(requestParameters: CreatePasswordRecoveryEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NewPasswordEmail>> {
        if (requestParameters['newPasswordEmail'] == null) {
            throw new runtime.RequiredError(
                'newPasswordEmail',
                'Required parameter "newPasswordEmail" was null or undefined when calling createPasswordRecoveryEmail().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/password_recovery_emails`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewPasswordEmailToJSON(requestParameters['newPasswordEmail']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NewPasswordEmailFromJSON(jsonValue));
    }

    /**
     * Send an email with a password recovery link to the email address of an existing account.  **Note:** The password recovery link expires 30 minutes after this endpoint is triggered. 
     * Request a password reset
     */
    async createPasswordRecoveryEmail(requestParameters: CreatePasswordRecoveryEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NewPasswordEmail> {
        const response = await this.createPasswordRecoveryEmailRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a session to use the Management API endpoints. Use the value of the `token` property provided in the response as bearer token in other API calls.  A token is valid for 3 months. In accordance with best pratices, use your generated token for all your API requests. Do **not** regenerate a token for each request.  This endpoint has a rate limit of 3 to 6 requests per second per account, depending on your setup.  <div class=\"redoc-section\">   <p class=\"title\">Granular API key</p>   Instead of using a session, you can also use the <a href=\"https://docs.talon.one/docs/product/account/dev-tools/managing-mapi-keys\">Management API key feature</a>   in the Campaign Manager to decide which endpoints can be used with a given key. </div> 
     * Create session
     */
    async createSessionRaw(requestParameters: CreateSessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Session>> {
        if (requestParameters['loginParams'] == null) {
            throw new runtime.RequiredError(
                'loginParams',
                'Required parameter "loginParams" was null or undefined when calling createSession().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/sessions`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginParamsToJSON(requestParameters['loginParams']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SessionFromJSON(jsonValue));
    }

    /**
     * Create a session to use the Management API endpoints. Use the value of the `token` property provided in the response as bearer token in other API calls.  A token is valid for 3 months. In accordance with best pratices, use your generated token for all your API requests. Do **not** regenerate a token for each request.  This endpoint has a rate limit of 3 to 6 requests per second per account, depending on your setup.  <div class=\"redoc-section\">   <p class=\"title\">Granular API key</p>   Instead of using a session, you can also use the <a href=\"https://docs.talon.one/docs/product/account/dev-tools/managing-mapi-keys\">Management API key feature</a>   in the Campaign Manager to decide which endpoints can be used with a given key. </div> 
     * Create session
     */
    async createSession(requestParameters: CreateSessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Session> {
        const response = await this.createSessionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new store in a specific Application.
     * Create store
     */
    async createStoreRaw(requestParameters: CreateStoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Store>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling createStore().'
            );
        }

        if (requestParameters['newStore'] == null) {
            throw new runtime.RequiredError(
                'newStore',
                'Required parameter "newStore" was null or undefined when calling createStore().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/stores`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewStoreToJSON(requestParameters['newStore']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreFromJSON(jsonValue));
    }

    /**
     * Create a new store in a specific Application.
     * Create store
     */
    async createStore(requestParameters: CreateStoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Store> {
        const response = await this.createStoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * [Disable a specific user](https://docs.talon.one/docs/product/account/account-settings/managing-users#disabling-a-user) by their email address. 
     * Disable user by email address
     */
    async deactivateUserByEmailRaw(requestParameters: DeactivateUserByEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['deactivateUserRequest'] == null) {
            throw new runtime.RequiredError(
                'deactivateUserRequest',
                'Required parameter "deactivateUserRequest" was null or undefined when calling deactivateUserByEmail().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/users/deactivate`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DeactivateUserRequestToJSON(requestParameters['deactivateUserRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * [Disable a specific user](https://docs.talon.one/docs/product/account/account-settings/managing-users#disabling-a-user) by their email address. 
     * Disable user by email address
     */
    async deactivateUserByEmail(requestParameters: DeactivateUserByEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deactivateUserByEmailRaw(requestParameters, initOverrides);
    }

    /**
     * Deduct points from the given loyalty card in the specified card-based loyalty program. 
     * Deduct points from card
     */
    async deductLoyaltyCardPointsRaw(requestParameters: DeductLoyaltyCardPointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling deductLoyaltyCardPoints().'
            );
        }

        if (requestParameters['loyaltyCardId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyCardId',
                'Required parameter "loyaltyCardId" was null or undefined when calling deductLoyaltyCardPoints().'
            );
        }

        if (requestParameters['deductLoyaltyPoints'] == null) {
            throw new runtime.RequiredError(
                'deductLoyaltyPoints',
                'Required parameter "deductLoyaltyPoints" was null or undefined when calling deductLoyaltyCardPoints().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/cards/{loyaltyCardId}/deduct_points`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));
        urlPath = urlPath.replace(`{${"loyaltyCardId"}}`, encodeURIComponent(String(requestParameters['loyaltyCardId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DeductLoyaltyPointsToJSON(requestParameters['deductLoyaltyPoints']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deduct points from the given loyalty card in the specified card-based loyalty program. 
     * Deduct points from card
     */
    async deductLoyaltyCardPoints(requestParameters: DeductLoyaltyCardPointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deductLoyaltyCardPointsRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a given account-level collection.
     * Delete account-level collection
     */
    async deleteAccountCollectionRaw(requestParameters: DeleteAccountCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['collectionId'] == null) {
            throw new runtime.RequiredError(
                'collectionId',
                'Required parameter "collectionId" was null or undefined when calling deleteAccountCollection().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/collections/{collectionId}`;
        urlPath = urlPath.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters['collectionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a given account-level collection.
     * Delete account-level collection
     */
    async deleteAccountCollection(requestParameters: DeleteAccountCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAccountCollectionRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the specified achievement.
     * Delete achievement
     */
    async deleteAchievementRaw(requestParameters: DeleteAchievementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling deleteAchievement().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling deleteAchievement().'
            );
        }

        if (requestParameters['achievementId'] == null) {
            throw new runtime.RequiredError(
                'achievementId',
                'Required parameter "achievementId" was null or undefined when calling deleteAchievement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/achievements/{achievementId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));
        urlPath = urlPath.replace(`{${"achievementId"}}`, encodeURIComponent(String(requestParameters['achievementId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the specified achievement.
     * Delete achievement
     */
    async deleteAchievement(requestParameters: DeleteAchievementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAchievementRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the given campaign.
     * Delete campaign
     */
    async deleteCampaignRaw(requestParameters: DeleteCampaignRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling deleteCampaign().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling deleteCampaign().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the given campaign.
     * Delete campaign
     */
    async deleteCampaign(requestParameters: DeleteCampaignRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteCampaignRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the store budgets for a given campaign.
     * Delete campaign store budgets
     */
    async deleteCampaignStoreBudgetsRaw(requestParameters: DeleteCampaignStoreBudgetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling deleteCampaignStoreBudgets().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling deleteCampaignStoreBudgets().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['action'] != null) {
            queryParameters['action'] = requestParameters['action'];
        }

        if (requestParameters['period'] != null) {
            queryParameters['period'] = requestParameters['period'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/stores/budgets`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the store budgets for a given campaign.
     * Delete campaign store budgets
     */
    async deleteCampaignStoreBudgets(requestParameters: DeleteCampaignStoreBudgetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteCampaignStoreBudgetsRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a given campaign-level collection.
     * Delete campaign-level collection
     */
    async deleteCollectionRaw(requestParameters: DeleteCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling deleteCollection().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling deleteCollection().'
            );
        }

        if (requestParameters['collectionId'] == null) {
            throw new runtime.RequiredError(
                'collectionId',
                'Required parameter "collectionId" was null or undefined when calling deleteCollection().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/collections/{collectionId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));
        urlPath = urlPath.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters['collectionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a given campaign-level collection.
     * Delete campaign-level collection
     */
    async deleteCollection(requestParameters: DeleteCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteCollectionRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the specified coupon.
     * Delete coupon
     */
    async deleteCouponRaw(requestParameters: DeleteCouponRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling deleteCoupon().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling deleteCoupon().'
            );
        }

        if (requestParameters['couponId'] == null) {
            throw new runtime.RequiredError(
                'couponId',
                'Required parameter "couponId" was null or undefined when calling deleteCoupon().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/coupons/{couponId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));
        urlPath = urlPath.replace(`{${"couponId"}}`, encodeURIComponent(String(requestParameters['couponId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the specified coupon.
     * Delete coupon
     */
    async deleteCoupon(requestParameters: DeleteCouponRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteCouponRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes all the coupons matching the specified criteria.
     * Delete coupons
     */
    async deleteCouponsRaw(requestParameters: DeleteCouponsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling deleteCoupons().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling deleteCoupons().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['value'] != null) {
            queryParameters['value'] = requestParameters['value'];
        }

        if (requestParameters['createdBefore'] != null) {
            queryParameters['createdBefore'] = (requestParameters['createdBefore'] as any).toISOString();
        }

        if (requestParameters['createdAfter'] != null) {
            queryParameters['createdAfter'] = (requestParameters['createdAfter'] as any).toISOString();
        }

        if (requestParameters['startsAfter'] != null) {
            queryParameters['startsAfter'] = (requestParameters['startsAfter'] as any).toISOString();
        }

        if (requestParameters['startsBefore'] != null) {
            queryParameters['startsBefore'] = (requestParameters['startsBefore'] as any).toISOString();
        }

        if (requestParameters['expiresAfter'] != null) {
            queryParameters['expiresAfter'] = (requestParameters['expiresAfter'] as any).toISOString();
        }

        if (requestParameters['expiresBefore'] != null) {
            queryParameters['expiresBefore'] = (requestParameters['expiresBefore'] as any).toISOString();
        }

        if (requestParameters['valid'] != null) {
            queryParameters['valid'] = requestParameters['valid'];
        }

        if (requestParameters['batchId'] != null) {
            queryParameters['batchId'] = requestParameters['batchId'];
        }

        if (requestParameters['usable'] != null) {
            queryParameters['usable'] = requestParameters['usable'];
        }

        if (requestParameters['referralId'] != null) {
            queryParameters['referralId'] = requestParameters['referralId'];
        }

        if (requestParameters['recipientIntegrationId'] != null) {
            queryParameters['recipientIntegrationId'] = requestParameters['recipientIntegrationId'];
        }

        if (requestParameters['exactMatch'] != null) {
            queryParameters['exactMatch'] = requestParameters['exactMatch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/coupons`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes all the coupons matching the specified criteria.
     * Delete coupons
     */
    async deleteCoupons(requestParameters: DeleteCouponsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteCouponsRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the given loyalty card.
     * Delete loyalty card
     */
    async deleteLoyaltyCardRaw(requestParameters: DeleteLoyaltyCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling deleteLoyaltyCard().'
            );
        }

        if (requestParameters['loyaltyCardId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyCardId',
                'Required parameter "loyaltyCardId" was null or undefined when calling deleteLoyaltyCard().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/cards/{loyaltyCardId}`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));
        urlPath = urlPath.replace(`{${"loyaltyCardId"}}`, encodeURIComponent(String(requestParameters['loyaltyCardId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the given loyalty card.
     * Delete loyalty card
     */
    async deleteLoyaltyCard(requestParameters: DeleteLoyaltyCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteLoyaltyCardRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the specified referral.
     * Delete referral
     */
    async deleteReferralRaw(requestParameters: DeleteReferralRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling deleteReferral().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling deleteReferral().'
            );
        }

        if (requestParameters['referralId'] == null) {
            throw new runtime.RequiredError(
                'referralId',
                'Required parameter "referralId" was null or undefined when calling deleteReferral().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/referrals/{referralId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));
        urlPath = urlPath.replace(`{${"referralId"}}`, encodeURIComponent(String(requestParameters['referralId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the specified referral.
     * Delete referral
     */
    async deleteReferral(requestParameters: DeleteReferralRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteReferralRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the specified store.
     * Delete store
     */
    async deleteStoreRaw(requestParameters: DeleteStoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling deleteStore().'
            );
        }

        if (requestParameters['storeId'] == null) {
            throw new runtime.RequiredError(
                'storeId',
                'Required parameter "storeId" was null or undefined when calling deleteStore().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/stores/{storeId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"storeId"}}`, encodeURIComponent(String(requestParameters['storeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the specified store.
     * Delete store
     */
    async deleteStore(requestParameters: DeleteStoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteStoreRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a specific user.
     * Delete user
     */
    async deleteUserRaw(requestParameters: DeleteUserApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling deleteUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/users/{userId}`;
        urlPath = urlPath.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a specific user.
     * Delete user
     */
    async deleteUser(requestParameters: DeleteUserApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteUserRaw(requestParameters, initOverrides);
    }

    /**
     * [Delete a specific user](https://docs.talon.one/docs/product/account/account-settings/managing-users#deleting-a-user) by their email address. 
     * Delete user by email address
     */
    async deleteUserByEmailRaw(requestParameters: DeleteUserByEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['deleteUserRequest'] == null) {
            throw new runtime.RequiredError(
                'deleteUserRequest',
                'Required parameter "deleteUserRequest" was null or undefined when calling deleteUserByEmail().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/users/delete`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DeleteUserRequestToJSON(requestParameters['deleteUserRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * [Delete a specific user](https://docs.talon.one/docs/product/account/account-settings/managing-users#deleting-a-user) by their email address. 
     * Delete user by email address
     */
    async deleteUserByEmail(requestParameters: DeleteUserByEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteUserByEmailRaw(requestParameters, initOverrides);
    }

    /**
     * Destroys the session.
     * Destroy session
     */
    async destroySessionRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/sessions`;

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Destroys the session.
     * Destroy session
     */
    async destroySession(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.destroySessionRaw(initOverrides);
    }

    /**
     * Disconnect the stores linked to a specific campaign.
     * Disconnect stores
     */
    async disconnectCampaignStoresRaw(requestParameters: DisconnectCampaignStoresRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling disconnectCampaignStores().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling disconnectCampaignStores().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/stores`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Disconnect the stores linked to a specific campaign.
     * Disconnect stores
     */
    async disconnectCampaignStores(requestParameters: DisconnectCampaignStoresRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.disconnectCampaignStoresRaw(requestParameters, initOverrides);
    }

    /**
     * Download a CSV file containing items from a given account-level collection.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/). 
     * Export account-level collection\'s items
     */
    async exportAccountCollectionItemsRaw(requestParameters: ExportAccountCollectionItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['collectionId'] == null) {
            throw new runtime.RequiredError(
                'collectionId',
                'Required parameter "collectionId" was null or undefined when calling exportAccountCollectionItems().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/collections/{collectionId}/export`;
        urlPath = urlPath.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters['collectionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download a CSV file containing items from a given account-level collection.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/). 
     * Export account-level collection\'s items
     */
    async exportAccountCollectionItems(requestParameters: ExportAccountCollectionItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportAccountCollectionItemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a CSV file containing a list of all the customers who have participated in and are currently participating in the given achievement.  The CSV file contains the following columns: - `profileIntegrationID`: The integration ID of the customer profile participating in the achievement. - `title`: The display name of the achievement in the Campaign Manager. - `target`: The required number of actions or the transactional milestone to complete the achievement. - `progress`: The current progress of the customer in the achievement. - `status`: The status of the achievement. Can be one of: [\'inprogress\', \'completed\', \'expired\']. - `startDate`: The date on which the customer profile started the achievement in RFC3339. - `endDate`: The date on which the achievement ends and resets for the customer profile in RFC3339. - `completionDate`: The date on which the customer profile completed the achievement in RFC3339. 
     * Export achievement customer data
     */
    async exportAchievementsRaw(requestParameters: ExportAchievementsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling exportAchievements().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling exportAchievements().'
            );
        }

        if (requestParameters['achievementId'] == null) {
            throw new runtime.RequiredError(
                'achievementId',
                'Required parameter "achievementId" was null or undefined when calling exportAchievements().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/achievements/{achievementId}/export`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));
        urlPath = urlPath.replace(`{${"achievementId"}}`, encodeURIComponent(String(requestParameters['achievementId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download a CSV file containing a list of all the customers who have participated in and are currently participating in the given achievement.  The CSV file contains the following columns: - `profileIntegrationID`: The integration ID of the customer profile participating in the achievement. - `title`: The display name of the achievement in the Campaign Manager. - `target`: The required number of actions or the transactional milestone to complete the achievement. - `progress`: The current progress of the customer in the achievement. - `status`: The status of the achievement. Can be one of: [\'inprogress\', \'completed\', \'expired\']. - `startDate`: The date on which the customer profile started the achievement in RFC3339. - `endDate`: The date on which the achievement ends and resets for the customer profile in RFC3339. - `completionDate`: The date on which the customer profile completed the achievement in RFC3339. 
     * Export achievement customer data
     */
    async exportAchievements(requestParameters: ExportAchievementsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportAchievementsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a CSV file containing the integration IDs of the members of an audience.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The file contains the following column: - `profileintegrationid`: The integration ID of the customer profile. 
     * Export audience members
     */
    async exportAudiencesMembershipsRaw(requestParameters: ExportAudiencesMembershipsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['audienceId'] == null) {
            throw new runtime.RequiredError(
                'audienceId',
                'Required parameter "audienceId" was null or undefined when calling exportAudiencesMemberships().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/audiences/{audienceId}/memberships/export`;
        urlPath = urlPath.replace(`{${"audienceId"}}`, encodeURIComponent(String(requestParameters['audienceId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download a CSV file containing the integration IDs of the members of an audience.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The file contains the following column: - `profileintegrationid`: The integration ID of the customer profile. 
     * Export audience members
     */
    async exportAudiencesMemberships(requestParameters: ExportAudiencesMembershipsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportAudiencesMembershipsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a CSV file containing the store budgets for a given campaign.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The CSV file contains the following columns:  - `store_integration_id`: The identifier of the store. - `limit`: The budget limit for the store. 
     * Export campaign store budgets
     */
    async exportCampaignStoreBudgetsRaw(requestParameters: ExportCampaignStoreBudgetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling exportCampaignStoreBudgets().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling exportCampaignStoreBudgets().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['action'] != null) {
            queryParameters['action'] = requestParameters['action'];
        }

        if (requestParameters['period'] != null) {
            queryParameters['period'] = requestParameters['period'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/stores/budgets/export`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download a CSV file containing the store budgets for a given campaign.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The CSV file contains the following columns:  - `store_integration_id`: The identifier of the store. - `limit`: The budget limit for the store. 
     * Export campaign store budgets
     */
    async exportCampaignStoreBudgets(requestParameters: ExportCampaignStoreBudgetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportCampaignStoreBudgetsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a CSV file containing the stores linked to a specific campaign.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The CSV file contains the following column:  - `store_integration_id`: The identifier of the store. 
     * Export stores
     */
    async exportCampaignStoresRaw(requestParameters: ExportCampaignStoresRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling exportCampaignStores().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling exportCampaignStores().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/stores/export`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download a CSV file containing the stores linked to a specific campaign.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The CSV file contains the following column:  - `store_integration_id`: The identifier of the store. 
     * Export stores
     */
    async exportCampaignStores(requestParameters: ExportCampaignStoresRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportCampaignStoresRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a CSV file containing items from a given campaign-level collection.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/). 
     * Export campaign-level collection\'s items
     */
    async exportCollectionItemsRaw(requestParameters: ExportCollectionItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling exportCollectionItems().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling exportCollectionItems().'
            );
        }

        if (requestParameters['collectionId'] == null) {
            throw new runtime.RequiredError(
                'collectionId',
                'Required parameter "collectionId" was null or undefined when calling exportCollectionItems().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/collections/{collectionId}/export`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));
        urlPath = urlPath.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters['collectionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download a CSV file containing items from a given campaign-level collection.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/). 
     * Export campaign-level collection\'s items
     */
    async exportCollectionItems(requestParameters: ExportCollectionItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportCollectionItemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a CSV file containing the coupons that match the given properties.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The CSV file can contain the following columns:  - `accountid`: The ID of your deployment. - `applicationid`: The ID of the Application this coupon is related to. - `attributes`: A json object describing _custom_ referral attribute names and their values. - `batchid`: The ID of the batch this coupon is part of. - `campaignid`: The ID of the campaign this coupon is related to. - `counter`: The number of times this coupon has been redeemed. - `created`: The creation date in RFC3339 of the coupon code. - `deleted`: Whether the coupon code is deleted. - `deleted_changelogid`: The ID of the delete event in the logs. - `discount_counter`: The amount of discount given by this coupon. - `discount_limitval`: The maximum discount amount that can be given be this coupon. - `expirydate`: The end date in RFC3339 of the code redemption period. - `id`: The internal ID of the coupon code. - `importid`: The ID of the import job that created this coupon. - `is_reservation_mandatory`: Whether this coupon requires a reservation to be redeemed. - `limits`: The limits set on this coupon. - `limitval`: The maximum number of redemptions of this code. - `recipientintegrationid`: The integration ID of the recipient of the coupon.   Only the customer with this integration ID can redeem this code. Available only for personal codes. - `referralid`: The ID of the referral code that triggered the creation of this coupon (create coupon effect). - `reservation`: Whether the coupon can be reserved for multiple customers. - `reservation_counter`: How many times this coupon has been reserved. - `reservation_limitval`: The maximum of number of reservations this coupon can have. - `startdate`: The start date in RFC3339 of the code redemption period. - `value`: The coupon code. 
     * Export coupons
     */
    async exportCouponsRaw(requestParameters: ExportCouponsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling exportCoupons().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['campaignId'] != null) {
            queryParameters['campaignId'] = requestParameters['campaignId'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['value'] != null) {
            queryParameters['value'] = requestParameters['value'];
        }

        if (requestParameters['createdBefore'] != null) {
            queryParameters['createdBefore'] = (requestParameters['createdBefore'] as any).toISOString();
        }

        if (requestParameters['createdAfter'] != null) {
            queryParameters['createdAfter'] = (requestParameters['createdAfter'] as any).toISOString();
        }

        if (requestParameters['valid'] != null) {
            queryParameters['valid'] = requestParameters['valid'];
        }

        if (requestParameters['usable'] != null) {
            queryParameters['usable'] = requestParameters['usable'];
        }

        if (requestParameters['referralId'] != null) {
            queryParameters['referralId'] = requestParameters['referralId'];
        }

        if (requestParameters['recipientIntegrationId'] != null) {
            queryParameters['recipientIntegrationId'] = requestParameters['recipientIntegrationId'];
        }

        if (requestParameters['batchId'] != null) {
            queryParameters['batchId'] = requestParameters['batchId'];
        }

        if (requestParameters['exactMatch'] != null) {
            queryParameters['exactMatch'] = requestParameters['exactMatch'];
        }

        if (requestParameters['dateFormat'] != null) {
            queryParameters['dateFormat'] = requestParameters['dateFormat'];
        }

        if (requestParameters['campaignState'] != null) {
            queryParameters['campaignState'] = requestParameters['campaignState'];
        }

        if (requestParameters['valuesOnly'] != null) {
            queryParameters['valuesOnly'] = requestParameters['valuesOnly'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/export_coupons`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download a CSV file containing the coupons that match the given properties.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The CSV file can contain the following columns:  - `accountid`: The ID of your deployment. - `applicationid`: The ID of the Application this coupon is related to. - `attributes`: A json object describing _custom_ referral attribute names and their values. - `batchid`: The ID of the batch this coupon is part of. - `campaignid`: The ID of the campaign this coupon is related to. - `counter`: The number of times this coupon has been redeemed. - `created`: The creation date in RFC3339 of the coupon code. - `deleted`: Whether the coupon code is deleted. - `deleted_changelogid`: The ID of the delete event in the logs. - `discount_counter`: The amount of discount given by this coupon. - `discount_limitval`: The maximum discount amount that can be given be this coupon. - `expirydate`: The end date in RFC3339 of the code redemption period. - `id`: The internal ID of the coupon code. - `importid`: The ID of the import job that created this coupon. - `is_reservation_mandatory`: Whether this coupon requires a reservation to be redeemed. - `limits`: The limits set on this coupon. - `limitval`: The maximum number of redemptions of this code. - `recipientintegrationid`: The integration ID of the recipient of the coupon.   Only the customer with this integration ID can redeem this code. Available only for personal codes. - `referralid`: The ID of the referral code that triggered the creation of this coupon (create coupon effect). - `reservation`: Whether the coupon can be reserved for multiple customers. - `reservation_counter`: How many times this coupon has been reserved. - `reservation_limitval`: The maximum of number of reservations this coupon can have. - `startdate`: The start date in RFC3339 of the code redemption period. - `value`: The coupon code. 
     * Export coupons
     */
    async exportCoupons(requestParameters: ExportCouponsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportCouponsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a CSV file containing the customer sessions that match the request.  **Important:** Archived sessions cannot be exported. See the [retention policy](https://docs.talon.one/docs/dev/server-infrastructure-and-data-retention).  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  - `id`: The internal ID of the session. - `firstsession`: Whether this is a first session. - `integrationid`: The integration ID of the session. - `applicationid`: The ID of the Application. - `profileid`: The internal ID of the customer profile. - `profileintegrationid`: The integration ID of the customer profile. - `created`: The timestamp when the session was created. - `state`: The [state](https://docs.talon.one/docs/dev/concepts/entities/customer-sessions#customer-session-states) of the session. - `cartitems`: The cart items in the session. - `discounts`: The discounts in the session. - `total`: The total value of cart items and additional costs in the session, before any discounts are applied. - `attributes`: The attributes set in the session. - `closedat`: Timestamp when the session was closed. - `cancelledat`: Timestamp when the session was cancelled. - `referral`: The referral code in the session. - `identifiers`: The identifiers in the session. - `additional_costs`: The [additional costs](https://docs.talon.one/docs/product/account/dev-tools/managing-additional-costs) in the session. - `updated`: Timestamp of the last session update. - `store_integration_id`: The integration ID of the store. - `coupons`: Coupon codes in the session. 
     * Export customer sessions
     */
    async exportCustomerSessionsRaw(requestParameters: ExportCustomerSessionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling exportCustomerSessions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['createdBefore'] != null) {
            queryParameters['createdBefore'] = (requestParameters['createdBefore'] as any).toISOString();
        }

        if (requestParameters['createdAfter'] != null) {
            queryParameters['createdAfter'] = (requestParameters['createdAfter'] as any).toISOString();
        }

        if (requestParameters['profileIntegrationId'] != null) {
            queryParameters['profileIntegrationId'] = requestParameters['profileIntegrationId'];
        }

        if (requestParameters['dateFormat'] != null) {
            queryParameters['dateFormat'] = requestParameters['dateFormat'];
        }

        if (requestParameters['customerSessionState'] != null) {
            queryParameters['customerSessionState'] = requestParameters['customerSessionState'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/export_customer_sessions`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download a CSV file containing the customer sessions that match the request.  **Important:** Archived sessions cannot be exported. See the [retention policy](https://docs.talon.one/docs/dev/server-infrastructure-and-data-retention).  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  - `id`: The internal ID of the session. - `firstsession`: Whether this is a first session. - `integrationid`: The integration ID of the session. - `applicationid`: The ID of the Application. - `profileid`: The internal ID of the customer profile. - `profileintegrationid`: The integration ID of the customer profile. - `created`: The timestamp when the session was created. - `state`: The [state](https://docs.talon.one/docs/dev/concepts/entities/customer-sessions#customer-session-states) of the session. - `cartitems`: The cart items in the session. - `discounts`: The discounts in the session. - `total`: The total value of cart items and additional costs in the session, before any discounts are applied. - `attributes`: The attributes set in the session. - `closedat`: Timestamp when the session was closed. - `cancelledat`: Timestamp when the session was cancelled. - `referral`: The referral code in the session. - `identifiers`: The identifiers in the session. - `additional_costs`: The [additional costs](https://docs.talon.one/docs/product/account/dev-tools/managing-additional-costs) in the session. - `updated`: Timestamp of the last session update. - `store_integration_id`: The integration ID of the store. - `coupons`: Coupon codes in the session. 
     * Export customer sessions
     */
    async exportCustomerSessions(requestParameters: ExportCustomerSessionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportCustomerSessionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a CSV file containing the tier information for customers of the specified loyalty program.  The generated file contains the following columns:  - `programid`: The identifier of the loyalty program. It is displayed in your Talon.One deployment URL. - `subledgerid`: The ID of the subledger associated with the loyalty program. This column is empty if the loyalty program has no subledger. In this case, refer to the export file name to get the ID of the loyalty program. - `customerprofileid`: The ID used to integrate customer profiles with the loyalty program. - `tiername`: The name of the tier. - `startdate`: The tier start date in RFC3339. - `expirydate`: The tier expiry date in RFC3339.  You can filter the results by providing the following optional input parameters:  - `subledgerIds` (optional): Filter results by an array of subledger IDs. If no value is provided, all subledger data for the specified loyalty program will be exported. - `tierNames` (optional): Filter results by an array of tier names. If no value is provided, all tier data for the specified loyalty program will be exported. 
     * Export customers\' tier data
     */
    async exportCustomersTiersRaw(requestParameters: ExportCustomersTiersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling exportCustomersTiers().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['subledgerIds'] != null) {
            queryParameters['subledgerIds'] = requestParameters['subledgerIds']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['tierNames'] != null) {
            queryParameters['tierNames'] = requestParameters['tierNames']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/export_customers_tiers`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download a CSV file containing the tier information for customers of the specified loyalty program.  The generated file contains the following columns:  - `programid`: The identifier of the loyalty program. It is displayed in your Talon.One deployment URL. - `subledgerid`: The ID of the subledger associated with the loyalty program. This column is empty if the loyalty program has no subledger. In this case, refer to the export file name to get the ID of the loyalty program. - `customerprofileid`: The ID used to integrate customer profiles with the loyalty program. - `tiername`: The name of the tier. - `startdate`: The tier start date in RFC3339. - `expirydate`: The tier expiry date in RFC3339.  You can filter the results by providing the following optional input parameters:  - `subledgerIds` (optional): Filter results by an array of subledger IDs. If no value is provided, all subledger data for the specified loyalty program will be exported. - `tierNames` (optional): Filter results by an array of tier names. If no value is provided, all tier data for the specified loyalty program will be exported. 
     * Export customers\' tier data
     */
    async exportCustomersTiers(requestParameters: ExportCustomersTiersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportCustomersTiersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a CSV file containing the triggered effects that match the given attributes.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The generated file can contain the following columns:  - `applicationid`: The ID of the Application. - `campaignid`: The ID of the campaign. - `couponid`: The ID of the coupon, when applicable to the effect. - `created`: The timestamp of the effect. - `event_type`: The name of the event. See the [docs](https://docs.talon.one/docs/dev/concepts/entities/events). - `eventid`: The internal ID of the effect. - `name`: The effect name. See the [docs](https://docs.talon.one/docs/dev/integration-api/api-effects). - `profileintegrationid`: The ID of the customer profile, when applicable. - `props`: The [properties](https://docs.talon.one/docs/dev/integration-api/api-effects) of the effect. - `ruleindex`: The index of the rule. - `rulesetid`: The ID of the rule set. - `sessionid`: The internal ID of the session that triggered the effect. - `profileid`: The internal ID of the customer profile. - `sessionintegrationid`: The integration ID of the session. - `total_revenue`: The total revenue. - `store_integration_id`: The integration ID of the store. You choose this ID when you create a store. 
     * Export triggered effects
     */
    async exportEffectsRaw(requestParameters: ExportEffectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling exportEffects().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['campaignId'] != null) {
            queryParameters['campaignId'] = requestParameters['campaignId'];
        }

        if (requestParameters['createdBefore'] != null) {
            queryParameters['createdBefore'] = (requestParameters['createdBefore'] as any).toISOString();
        }

        if (requestParameters['createdAfter'] != null) {
            queryParameters['createdAfter'] = (requestParameters['createdAfter'] as any).toISOString();
        }

        if (requestParameters['dateFormat'] != null) {
            queryParameters['dateFormat'] = requestParameters['dateFormat'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/export_effects`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download a CSV file containing the triggered effects that match the given attributes.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The generated file can contain the following columns:  - `applicationid`: The ID of the Application. - `campaignid`: The ID of the campaign. - `couponid`: The ID of the coupon, when applicable to the effect. - `created`: The timestamp of the effect. - `event_type`: The name of the event. See the [docs](https://docs.talon.one/docs/dev/concepts/entities/events). - `eventid`: The internal ID of the effect. - `name`: The effect name. See the [docs](https://docs.talon.one/docs/dev/integration-api/api-effects). - `profileintegrationid`: The ID of the customer profile, when applicable. - `props`: The [properties](https://docs.talon.one/docs/dev/integration-api/api-effects) of the effect. - `ruleindex`: The index of the rule. - `rulesetid`: The ID of the rule set. - `sessionid`: The internal ID of the session that triggered the effect. - `profileid`: The internal ID of the customer profile. - `sessionintegrationid`: The integration ID of the session. - `total_revenue`: The total revenue. - `store_integration_id`: The integration ID of the store. You choose this ID when you create a store. 
     * Export triggered effects
     */
    async exportEffects(requestParameters: ExportEffectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportEffectsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  Deprecation notice: Support for requests to this endpoint will end soon. To export customer loyalty balances to CSV, use the [Export customer loyalty balances to CSV](/management-api#tag/Loyalty/operation/exportLoyaltyBalances) endpoint.  Download a CSV file containing the balance of each customer in the loyalty program.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/). 
     * Export customer loyalty balance to CSV
     * @deprecated
     */
    async exportLoyaltyBalanceRaw(requestParameters: ExportLoyaltyBalanceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling exportLoyaltyBalance().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['endDate'] != null) {
            queryParameters['endDate'] = (requestParameters['endDate'] as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/export_customer_balance`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     *  Deprecation notice: Support for requests to this endpoint will end soon. To export customer loyalty balances to CSV, use the [Export customer loyalty balances to CSV](/management-api#tag/Loyalty/operation/exportLoyaltyBalances) endpoint.  Download a CSV file containing the balance of each customer in the loyalty program.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/). 
     * Export customer loyalty balance to CSV
     * @deprecated
     */
    async exportLoyaltyBalance(requestParameters: ExportLoyaltyBalanceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportLoyaltyBalanceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a CSV file containing the balance of each customer in the loyalty program.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The generated file can contain the following columns:  - `loyaltyProgramID`: The ID of the loyalty program. - `loyaltySubledger`: The name of the subdleger, when applicatble. - `profileIntegrationID`: The integration ID of the customer profile. - `currentBalance`: The current point balance. - `pendingBalance`: The number of pending points. - `expiredBalance`: The number of expired points. - `spentBalance`: The number of spent points. - `currentTier`: The tier that the customer is in at the time of the export. 
     * Export customer loyalty balances
     */
    async exportLoyaltyBalancesRaw(requestParameters: ExportLoyaltyBalancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling exportLoyaltyBalances().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['endDate'] != null) {
            queryParameters['endDate'] = (requestParameters['endDate'] as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/export_customer_balances`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download a CSV file containing the balance of each customer in the loyalty program.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The generated file can contain the following columns:  - `loyaltyProgramID`: The ID of the loyalty program. - `loyaltySubledger`: The name of the subdleger, when applicatble. - `profileIntegrationID`: The integration ID of the customer profile. - `currentBalance`: The current point balance. - `pendingBalance`: The number of pending points. - `expiredBalance`: The number of expired points. - `spentBalance`: The number of spent points. - `currentTier`: The tier that the customer is in at the time of the export. 
     * Export customer loyalty balances
     */
    async exportLoyaltyBalances(requestParameters: ExportLoyaltyBalancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportLoyaltyBalancesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a CSV file containing the balances of all cards in the loyalty program.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The CSV file contains the following columns: - `loyaltyProgramID`: The ID of the loyalty program. - `loyaltySubledger`: The name of the subdleger, when applicatble. - `cardIdentifier`: The alphanumeric identifier of the loyalty card. - `cardState`:The state of the loyalty card. It can be `active` or `inactive`. - `currentBalance`: The current point balance. - `pendingBalance`: The number of pending points. - `expiredBalance`: The number of expired points. - `spentBalance`: The number of spent points. 
     * Export all card transaction logs
     */
    async exportLoyaltyCardBalancesRaw(requestParameters: ExportLoyaltyCardBalancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling exportLoyaltyCardBalances().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['endDate'] != null) {
            queryParameters['endDate'] = (requestParameters['endDate'] as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/export_card_balances`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download a CSV file containing the balances of all cards in the loyalty program.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The CSV file contains the following columns: - `loyaltyProgramID`: The ID of the loyalty program. - `loyaltySubledger`: The name of the subdleger, when applicatble. - `cardIdentifier`: The alphanumeric identifier of the loyalty card. - `cardState`:The state of the loyalty card. It can be `active` or `inactive`. - `currentBalance`: The current point balance. - `pendingBalance`: The number of pending points. - `expiredBalance`: The number of expired points. - `spentBalance`: The number of spent points. 
     * Export all card transaction logs
     */
    async exportLoyaltyCardBalances(requestParameters: ExportLoyaltyCardBalancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportLoyaltyCardBalancesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a CSV file containing a loyalty card ledger log of the loyalty program.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/). 
     * Export card\'s ledger log
     */
    async exportLoyaltyCardLedgerRaw(requestParameters: ExportLoyaltyCardLedgerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling exportLoyaltyCardLedger().'
            );
        }

        if (requestParameters['loyaltyCardId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyCardId',
                'Required parameter "loyaltyCardId" was null or undefined when calling exportLoyaltyCardLedger().'
            );
        }

        if (requestParameters['rangeStart'] == null) {
            throw new runtime.RequiredError(
                'rangeStart',
                'Required parameter "rangeStart" was null or undefined when calling exportLoyaltyCardLedger().'
            );
        }

        if (requestParameters['rangeEnd'] == null) {
            throw new runtime.RequiredError(
                'rangeEnd',
                'Required parameter "rangeEnd" was null or undefined when calling exportLoyaltyCardLedger().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['rangeStart'] != null) {
            queryParameters['rangeStart'] = (requestParameters['rangeStart'] as any).toISOString();
        }

        if (requestParameters['rangeEnd'] != null) {
            queryParameters['rangeEnd'] = (requestParameters['rangeEnd'] as any).toISOString();
        }

        if (requestParameters['dateFormat'] != null) {
            queryParameters['dateFormat'] = requestParameters['dateFormat'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/cards/{loyaltyCardId}/export_log`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));
        urlPath = urlPath.replace(`{${"loyaltyCardId"}}`, encodeURIComponent(String(requestParameters['loyaltyCardId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download a CSV file containing a loyalty card ledger log of the loyalty program.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/). 
     * Export card\'s ledger log
     */
    async exportLoyaltyCardLedger(requestParameters: ExportLoyaltyCardLedgerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportLoyaltyCardLedgerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a CSV file containing the loyalty cards from a specified loyalty program.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The CSV file contains the following columns: - `identifier`: The unique identifier of the loyalty card. - `created`: The date and time the loyalty card was created. - `status`: The status of the loyalty card. - `userpercardlimit`: The maximum number of customer profiles that can be linked to the card. - `customerprofileids`: Integration IDs of the customer profiles linked to the card. - `blockreason`: The reason for transferring and blocking the loyalty card. - `generated`: An indicator of whether the loyalty card was generated. - `batchid`: The ID of the batch the loyalty card is in. 
     * Export loyalty cards
     */
    async exportLoyaltyCardsRaw(requestParameters: ExportLoyaltyCardsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling exportLoyaltyCards().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['batchId'] != null) {
            queryParameters['batchId'] = requestParameters['batchId'];
        }

        if (requestParameters['createdBefore'] != null) {
            queryParameters['createdBefore'] = (requestParameters['createdBefore'] as any).toISOString();
        }

        if (requestParameters['createdAfter'] != null) {
            queryParameters['createdAfter'] = (requestParameters['createdAfter'] as any).toISOString();
        }

        if (requestParameters['dateFormat'] != null) {
            queryParameters['dateFormat'] = requestParameters['dateFormat'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/cards/export`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download a CSV file containing the loyalty cards from a specified loyalty program.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The CSV file contains the following columns: - `identifier`: The unique identifier of the loyalty card. - `created`: The date and time the loyalty card was created. - `status`: The status of the loyalty card. - `userpercardlimit`: The maximum number of customer profiles that can be linked to the card. - `customerprofileids`: Integration IDs of the customer profiles linked to the card. - `blockreason`: The reason for transferring and blocking the loyalty card. - `generated`: An indicator of whether the loyalty card was generated. - `batchid`: The ID of the batch the loyalty card is in. 
     * Export loyalty cards
     */
    async exportLoyaltyCards(requestParameters: ExportLoyaltyCardsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportLoyaltyCardsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a CSV file containing a customer\'s transaction logs in the loyalty program.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The generated file can contain the following columns:  - `customerprofileid`: The ID of the profile. - `customersessionid`: The ID of the customer session. - `rulesetid`: The ID of the rule set. - `rulename`: The name of the rule. - `programid`: The ID of the loyalty program. - `type`: The transaction type, such as `addition` or `subtraction`. - `name`: The reason for the transaction. - `subledgerid`: The ID of the subledger, when applicable. - `startdate`: The start date of the program. - `expirydate`: The expiration date of the program. - `id`: The ID of the transaction. - `created`: The timestamp of the creation of the loyalty program. - `amount`: The number of points in that transaction. - `archived`: Whether the session related to the transaction is archived. - `campaignid`: The ID of the campaign. - `flags`: The flags of the transaction, when applicable. The `createsNegativeBalance` flag indicates whether the transaction results in a negative balance. - `transactionUUID`: Unique identifier of the transaction in the UUID format. 
     * Export customer\'s transaction logs
     */
    async exportLoyaltyLedgerRaw(requestParameters: ExportLoyaltyLedgerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['rangeStart'] == null) {
            throw new runtime.RequiredError(
                'rangeStart',
                'Required parameter "rangeStart" was null or undefined when calling exportLoyaltyLedger().'
            );
        }

        if (requestParameters['rangeEnd'] == null) {
            throw new runtime.RequiredError(
                'rangeEnd',
                'Required parameter "rangeEnd" was null or undefined when calling exportLoyaltyLedger().'
            );
        }

        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling exportLoyaltyLedger().'
            );
        }

        if (requestParameters['integrationId'] == null) {
            throw new runtime.RequiredError(
                'integrationId',
                'Required parameter "integrationId" was null or undefined when calling exportLoyaltyLedger().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['rangeStart'] != null) {
            queryParameters['rangeStart'] = (requestParameters['rangeStart'] as any).toISOString();
        }

        if (requestParameters['rangeEnd'] != null) {
            queryParameters['rangeEnd'] = (requestParameters['rangeEnd'] as any).toISOString();
        }

        if (requestParameters['dateFormat'] != null) {
            queryParameters['dateFormat'] = requestParameters['dateFormat'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/profile/{integrationId}/export_log`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));
        urlPath = urlPath.replace(`{${"integrationId"}}`, encodeURIComponent(String(requestParameters['integrationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download a CSV file containing a customer\'s transaction logs in the loyalty program.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The generated file can contain the following columns:  - `customerprofileid`: The ID of the profile. - `customersessionid`: The ID of the customer session. - `rulesetid`: The ID of the rule set. - `rulename`: The name of the rule. - `programid`: The ID of the loyalty program. - `type`: The transaction type, such as `addition` or `subtraction`. - `name`: The reason for the transaction. - `subledgerid`: The ID of the subledger, when applicable. - `startdate`: The start date of the program. - `expirydate`: The expiration date of the program. - `id`: The ID of the transaction. - `created`: The timestamp of the creation of the loyalty program. - `amount`: The number of points in that transaction. - `archived`: Whether the session related to the transaction is archived. - `campaignid`: The ID of the campaign. - `flags`: The flags of the transaction, when applicable. The `createsNegativeBalance` flag indicates whether the transaction results in a negative balance. - `transactionUUID`: Unique identifier of the transaction in the UUID format. 
     * Export customer\'s transaction logs
     */
    async exportLoyaltyLedger(requestParameters: ExportLoyaltyLedgerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportLoyaltyLedgerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a CSV file containing the giveaway codes of a specific giveaway pool.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The CSV file contains the following columns:  - `id`: The internal ID of the giveaway. - `poolid`: The internal ID of the giveaway pool. - `code`: The giveaway code. - `startdate`: The validity start date in RFC3339 of the giveaway (can be empty). - `enddate`: The validity end date in RFC3339 of the giveaway (can be empty). - `attributes`: Any custom attributes associated with the giveaway code (can be empty). - `used`: An indication of whether the giveaway is already awarded. - `importid`: The ID of the import which created the giveaway. - `created`: The creation time of the giveaway code. - `profileintegrationid`: The third-party integration ID of the customer profile that was awarded the giveaway. Can be empty if the giveaway was not awarded. - `profileid`: The internal ID of the customer profile that was awarded the giveaway. Can be empty if the giveaway was not awarded or an internal ID does not exist. 
     * Export giveaway codes of a giveaway pool
     */
    async exportPoolGiveawaysRaw(requestParameters: ExportPoolGiveawaysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['poolId'] == null) {
            throw new runtime.RequiredError(
                'poolId',
                'Required parameter "poolId" was null or undefined when calling exportPoolGiveaways().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['createdBefore'] != null) {
            queryParameters['createdBefore'] = (requestParameters['createdBefore'] as any).toISOString();
        }

        if (requestParameters['createdAfter'] != null) {
            queryParameters['createdAfter'] = (requestParameters['createdAfter'] as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/giveaways/pools/{poolId}/export`;
        urlPath = urlPath.replace(`{${"poolId"}}`, encodeURIComponent(String(requestParameters['poolId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download a CSV file containing the giveaway codes of a specific giveaway pool.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The CSV file contains the following columns:  - `id`: The internal ID of the giveaway. - `poolid`: The internal ID of the giveaway pool. - `code`: The giveaway code. - `startdate`: The validity start date in RFC3339 of the giveaway (can be empty). - `enddate`: The validity end date in RFC3339 of the giveaway (can be empty). - `attributes`: Any custom attributes associated with the giveaway code (can be empty). - `used`: An indication of whether the giveaway is already awarded. - `importid`: The ID of the import which created the giveaway. - `created`: The creation time of the giveaway code. - `profileintegrationid`: The third-party integration ID of the customer profile that was awarded the giveaway. Can be empty if the giveaway was not awarded. - `profileid`: The internal ID of the customer profile that was awarded the giveaway. Can be empty if the giveaway was not awarded or an internal ID does not exist. 
     * Export giveaway codes of a giveaway pool
     */
    async exportPoolGiveaways(requestParameters: ExportPoolGiveawaysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportPoolGiveawaysRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a CSV file containing the referrals that match the given parameters.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The CSV file contains the following columns:  - `code`: The referral code. - `advocateprofileintegrationid`: The profile ID of the advocate. - `startdate`: The start date in RFC3339 of the code redemption period. - `expirydate`: The end date in RFC3339 of the code redemption period. - `limitval`: The maximum number of redemptions of this code. Defaults to `1` when left blank. - `attributes`: A json object describing _custom_ referral attribute names and their values. 
     * Export referrals
     */
    async exportReferralsRaw(requestParameters: ExportReferralsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling exportReferrals().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['campaignId'] != null) {
            queryParameters['campaignId'] = requestParameters['campaignId'];
        }

        if (requestParameters['createdBefore'] != null) {
            queryParameters['createdBefore'] = (requestParameters['createdBefore'] as any).toISOString();
        }

        if (requestParameters['createdAfter'] != null) {
            queryParameters['createdAfter'] = (requestParameters['createdAfter'] as any).toISOString();
        }

        if (requestParameters['valid'] != null) {
            queryParameters['valid'] = requestParameters['valid'];
        }

        if (requestParameters['usable'] != null) {
            queryParameters['usable'] = requestParameters['usable'];
        }

        if (requestParameters['batchId'] != null) {
            queryParameters['batchId'] = requestParameters['batchId'];
        }

        if (requestParameters['dateFormat'] != null) {
            queryParameters['dateFormat'] = requestParameters['dateFormat'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/export_referrals`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download a CSV file containing the referrals that match the given parameters.  **Tip:** If the exported CSV file is too large to view, you can [split it into multiple files](https://www.makeuseof.com/tag/how-to-split-a-huge-csv-excel-workbook-into-seperate-files/).  The CSV file contains the following columns:  - `code`: The referral code. - `advocateprofileintegrationid`: The profile ID of the advocate. - `startdate`: The start date in RFC3339 of the code redemption period. - `expirydate`: The end date in RFC3339 of the code redemption period. - `limitval`: The maximum number of redemptions of this code. Defaults to `1` when left blank. - `attributes`: A json object describing _custom_ referral attribute names and their values. 
     * Export referrals
     */
    async exportReferrals(requestParameters: ExportReferralsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportReferralsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a summary of the reasons for coupon redemption failures in a given customer session. 
     * Summarize coupon redemption failures in session
     */
    async generateCouponRejectionsRaw(requestParameters: GenerateCouponRejectionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenerateCouponRejections200Response>> {
        if (requestParameters['sessionIntegrationId'] == null) {
            throw new runtime.RequiredError(
                'sessionIntegrationId',
                'Required parameter "sessionIntegrationId" was null or undefined when calling generateCouponRejections().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['sessionIntegrationId'] != null) {
            queryParameters['sessionIntegrationId'] = requestParameters['sessionIntegrationId'];
        }

        if (requestParameters['applicationId'] != null) {
            queryParameters['applicationId'] = requestParameters['applicationId'];
        }

        if (requestParameters['language'] != null) {
            queryParameters['language'] = requestParameters['language'];
        }

        if (requestParameters['couponCode'] != null) {
            queryParameters['couponCode'] = requestParameters['couponCode'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/coupon_rejections`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenerateCouponRejections200ResponseFromJSON(jsonValue));
    }

    /**
     * Create a summary of the reasons for coupon redemption failures in a given customer session. 
     * Summarize coupon redemption failures in session
     */
    async generateCouponRejections(requestParameters: GenerateCouponRejectionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenerateCouponRejections200Response> {
        const response = await this.generateCouponRejectionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the list of API calls sent to the specified Application. 
     * Get access logs for Application
     */
    async getAccessLogsWithoutTotalCountRaw(requestParameters: GetAccessLogsWithoutTotalCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAccessLogsWithoutTotalCount200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getAccessLogsWithoutTotalCount().'
            );
        }

        if (requestParameters['rangeStart'] == null) {
            throw new runtime.RequiredError(
                'rangeStart',
                'Required parameter "rangeStart" was null or undefined when calling getAccessLogsWithoutTotalCount().'
            );
        }

        if (requestParameters['rangeEnd'] == null) {
            throw new runtime.RequiredError(
                'rangeEnd',
                'Required parameter "rangeEnd" was null or undefined when calling getAccessLogsWithoutTotalCount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['method'] != null) {
            queryParameters['method'] = requestParameters['method'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['rangeStart'] != null) {
            queryParameters['rangeStart'] = (requestParameters['rangeStart'] as any).toISOString();
        }

        if (requestParameters['rangeEnd'] != null) {
            queryParameters['rangeEnd'] = (requestParameters['rangeEnd'] as any).toISOString();
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/access_logs/no_total`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetAccessLogsWithoutTotalCount200ResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the list of API calls sent to the specified Application. 
     * Get access logs for Application
     */
    async getAccessLogsWithoutTotalCount(requestParameters: GetAccessLogsWithoutTotalCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAccessLogsWithoutTotalCount200Response> {
        const response = await this.getAccessLogsWithoutTotalCountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the details of your companies Talon.One account. 
     * Get account details
     */
    async getAccountRaw(requestParameters: GetAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Account>> {
        if (requestParameters['accountId'] == null) {
            throw new runtime.RequiredError(
                'accountId',
                'Required parameter "accountId" was null or undefined when calling getAccount().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/accounts/{accountId}`;
        urlPath = urlPath.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters['accountId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountFromJSON(jsonValue));
    }

    /**
     * Return the details of your companies Talon.One account. 
     * Get account details
     */
    async getAccount(requestParameters: GetAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Account> {
        const response = await this.getAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the analytics of your Talon.One account. 
     * Get account analytics
     */
    async getAccountAnalyticsRaw(requestParameters: GetAccountAnalyticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountAnalytics>> {
        if (requestParameters['accountId'] == null) {
            throw new runtime.RequiredError(
                'accountId',
                'Required parameter "accountId" was null or undefined when calling getAccountAnalytics().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/accounts/{accountId}/analytics`;
        urlPath = urlPath.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters['accountId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountAnalyticsFromJSON(jsonValue));
    }

    /**
     * Return the analytics of your Talon.One account. 
     * Get account analytics
     */
    async getAccountAnalytics(requestParameters: GetAccountAnalyticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountAnalytics> {
        const response = await this.getAccountAnalyticsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a given account-level collection.
     * Get account-level collection
     */
    async getAccountCollectionRaw(requestParameters: GetAccountCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Collection>> {
        if (requestParameters['collectionId'] == null) {
            throw new runtime.RequiredError(
                'collectionId',
                'Required parameter "collectionId" was null or undefined when calling getAccountCollection().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/collections/{collectionId}`;
        urlPath = urlPath.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters['collectionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CollectionFromJSON(jsonValue));
    }

    /**
     * Retrieve a given account-level collection.
     * Get account-level collection
     */
    async getAccountCollection(requestParameters: GetAccountCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Collection> {
        const response = await this.getAccountCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the details of a specific achievement.
     * Get achievement
     */
    async getAchievementRaw(requestParameters: GetAchievementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Achievement>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getAchievement().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling getAchievement().'
            );
        }

        if (requestParameters['achievementId'] == null) {
            throw new runtime.RequiredError(
                'achievementId',
                'Required parameter "achievementId" was null or undefined when calling getAchievement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/achievements/{achievementId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));
        urlPath = urlPath.replace(`{${"achievementId"}}`, encodeURIComponent(String(requestParameters['achievementId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AchievementFromJSON(jsonValue));
    }

    /**
     * Get the details of a specific achievement.
     * Get achievement
     */
    async getAchievement(requestParameters: GetAchievementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Achievement> {
        const response = await this.getAchievementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the additional cost. 
     * Get additional cost
     */
    async getAdditionalCostRaw(requestParameters: GetAdditionalCostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountAdditionalCost>> {
        if (requestParameters['additionalCostId'] == null) {
            throw new runtime.RequiredError(
                'additionalCostId',
                'Required parameter "additionalCostId" was null or undefined when calling getAdditionalCost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/additional_costs/{additionalCostId}`;
        urlPath = urlPath.replace(`{${"additionalCostId"}}`, encodeURIComponent(String(requestParameters['additionalCostId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountAdditionalCostFromJSON(jsonValue));
    }

    /**
     * Returns the additional cost. 
     * Get additional cost
     */
    async getAdditionalCost(requestParameters: GetAdditionalCostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountAdditionalCost> {
        const response = await this.getAdditionalCostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all the defined additional costs for the account. 
     * List additional costs
     */
    async getAdditionalCostsRaw(requestParameters: GetAdditionalCostsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAdditionalCosts200Response>> {
        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/additional_costs`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetAdditionalCosts200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns all the defined additional costs for the account. 
     * List additional costs
     */
    async getAdditionalCosts(requestParameters: GetAdditionalCostsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAdditionalCosts200Response> {
        const response = await this.getAdditionalCostsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the application specified by the ID.
     * Get Application
     */
    async getApplicationRaw(requestParameters: GetApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Application>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getApplication().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationFromJSON(jsonValue));
    }

    /**
     * Get the application specified by the ID.
     * Get Application
     */
    async getApplication(requestParameters: GetApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Application> {
        const response = await this.getApplicationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Display the health of the Application and show the last time the Application was used.  You can also find this information in the Campaign Manager. In your Application, click **Settings** > **Integration API Keys**. See the [docs](https://docs.talon.one/docs/dev/tutorials/monitoring-integration-status). 
     * Get Application health
     */
    async getApplicationApiHealthRaw(requestParameters: GetApplicationApiHealthRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApplicationApiHealth>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getApplicationApiHealth().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/health_report`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationApiHealthFromJSON(jsonValue));
    }

    /**
     * Display the health of the Application and show the last time the Application was used.  You can also find this information in the Campaign Manager. In your Application, click **Settings** > **Integration API Keys**. See the [docs](https://docs.talon.one/docs/dev/tutorials/monitoring-integration-status). 
     * Get Application health
     */
    async getApplicationApiHealth(requestParameters: GetApplicationApiHealthRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApplicationApiHealth> {
        const response = await this.getApplicationApiHealthRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the customers of the specified application. 
     * Get application\'s customer
     */
    async getApplicationCustomerRaw(requestParameters: GetApplicationCustomerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApplicationCustomer>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getApplicationCustomer().'
            );
        }

        if (requestParameters['customerId'] == null) {
            throw new runtime.RequiredError(
                'customerId',
                'Required parameter "customerId" was null or undefined when calling getApplicationCustomer().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/customers/{customerId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"customerId"}}`, encodeURIComponent(String(requestParameters['customerId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationCustomerFromJSON(jsonValue));
    }

    /**
     * Retrieve the customers of the specified application. 
     * Get application\'s customer
     */
    async getApplicationCustomer(requestParameters: GetApplicationCustomerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApplicationCustomer> {
        const response = await this.getApplicationCustomerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List the friends referred by the specified customer profile in this Application. 
     * List friends referred by customer profile
     */
    async getApplicationCustomerFriendsRaw(requestParameters: GetApplicationCustomerFriendsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetApplicationCustomerFriends200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getApplicationCustomerFriends().'
            );
        }

        if (requestParameters['integrationId'] == null) {
            throw new runtime.RequiredError(
                'integrationId',
                'Required parameter "integrationId" was null or undefined when calling getApplicationCustomerFriends().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['withTotalResultSize'] != null) {
            queryParameters['withTotalResultSize'] = requestParameters['withTotalResultSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/profile/{integrationId}/friends`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"integrationId"}}`, encodeURIComponent(String(requestParameters['integrationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetApplicationCustomerFriends200ResponseFromJSON(jsonValue));
    }

    /**
     * List the friends referred by the specified customer profile in this Application. 
     * List friends referred by customer profile
     */
    async getApplicationCustomerFriends(requestParameters: GetApplicationCustomerFriendsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetApplicationCustomerFriends200Response> {
        const response = await this.getApplicationCustomerFriendsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all the customers of the specified application.
     * List application\'s customers
     */
    async getApplicationCustomersRaw(requestParameters: GetApplicationCustomersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetApplicationCustomers200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getApplicationCustomers().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['integrationId'] != null) {
            queryParameters['integrationId'] = requestParameters['integrationId'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['withTotalResultSize'] != null) {
            queryParameters['withTotalResultSize'] = requestParameters['withTotalResultSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/customers`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetApplicationCustomers200ResponseFromJSON(jsonValue));
    }

    /**
     * List all the customers of the specified application.
     * List application\'s customers
     */
    async getApplicationCustomers(requestParameters: GetApplicationCustomersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetApplicationCustomers200Response> {
        const response = await this.getApplicationCustomersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of the application customers matching the provided criteria.  The match is successful if all the attributes of the request are found in a profile, even if the profile has more attributes that are not present on the request. 
     * List application customers matching the given attributes
     */
    async getApplicationCustomersByAttributesRaw(requestParameters: GetApplicationCustomersByAttributesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetApplicationCustomersByAttributes200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getApplicationCustomersByAttributes().'
            );
        }

        if (requestParameters['customerProfileSearchQuery'] == null) {
            throw new runtime.RequiredError(
                'customerProfileSearchQuery',
                'Required parameter "customerProfileSearchQuery" was null or undefined when calling getApplicationCustomersByAttributes().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['withTotalResultSize'] != null) {
            queryParameters['withTotalResultSize'] = requestParameters['withTotalResultSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/customer_search`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerProfileSearchQueryToJSON(requestParameters['customerProfileSearchQuery']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetApplicationCustomersByAttributes200ResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of the application customers matching the provided criteria.  The match is successful if all the attributes of the request are found in a profile, even if the profile has more attributes that are not present on the request. 
     * List application customers matching the given attributes
     */
    async getApplicationCustomersByAttributes(requestParameters: GetApplicationCustomersByAttributesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetApplicationCustomersByAttributes200Response> {
        const response = await this.getApplicationCustomersByAttributesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all of the distinct values of the Event `type` property for events recorded in the application.  See also: [Track an event](https://docs.talon.one/integration-api#tag/Events/operation/trackEventV2) 
     * List Applications event types
     */
    async getApplicationEventTypesRaw(requestParameters: GetApplicationEventTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetApplicationEventTypes200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getApplicationEventTypes().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/event_types`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetApplicationEventTypes200ResponseFromJSON(jsonValue));
    }

    /**
     * Get all of the distinct values of the Event `type` property for events recorded in the application.  See also: [Track an event](https://docs.talon.one/integration-api#tag/Events/operation/trackEventV2) 
     * List Applications event types
     */
    async getApplicationEventTypes(requestParameters: GetApplicationEventTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetApplicationEventTypes200Response> {
        const response = await this.getApplicationEventTypesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists all events recorded for an application. Instead of having the total number of results in the response, this endpoint only mentions whether there are more results. 
     * List Applications events
     */
    async getApplicationEventsWithoutTotalCountRaw(requestParameters: GetApplicationEventsWithoutTotalCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetApplicationEventsWithoutTotalCount200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getApplicationEventsWithoutTotalCount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['createdBefore'] != null) {
            queryParameters['createdBefore'] = (requestParameters['createdBefore'] as any).toISOString();
        }

        if (requestParameters['createdAfter'] != null) {
            queryParameters['createdAfter'] = (requestParameters['createdAfter'] as any).toISOString();
        }

        if (requestParameters['session'] != null) {
            queryParameters['session'] = requestParameters['session'];
        }

        if (requestParameters['profile'] != null) {
            queryParameters['profile'] = requestParameters['profile'];
        }

        if (requestParameters['customerName'] != null) {
            queryParameters['customerName'] = requestParameters['customerName'];
        }

        if (requestParameters['customerEmail'] != null) {
            queryParameters['customerEmail'] = requestParameters['customerEmail'];
        }

        if (requestParameters['couponCode'] != null) {
            queryParameters['couponCode'] = requestParameters['couponCode'];
        }

        if (requestParameters['referralCode'] != null) {
            queryParameters['referralCode'] = requestParameters['referralCode'];
        }

        if (requestParameters['ruleQuery'] != null) {
            queryParameters['ruleQuery'] = requestParameters['ruleQuery'];
        }

        if (requestParameters['campaignQuery'] != null) {
            queryParameters['campaignQuery'] = requestParameters['campaignQuery'];
        }

        if (requestParameters['effectType'] != null) {
            queryParameters['effectType'] = requestParameters['effectType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/events/no_total`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetApplicationEventsWithoutTotalCount200ResponseFromJSON(jsonValue));
    }

    /**
     * Lists all events recorded for an application. Instead of having the total number of results in the response, this endpoint only mentions whether there are more results. 
     * List Applications events
     */
    async getApplicationEventsWithoutTotalCount(requestParameters: GetApplicationEventsWithoutTotalCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetApplicationEventsWithoutTotalCount200Response> {
        const response = await this.getApplicationEventsWithoutTotalCountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the details of the given session. You can list the sessions with the [List Application sessions](https://docs.talon.one/management-api#tag/Customer-data/operation/getApplicationSessions) endpoint. 
     * Get Application session
     */
    async getApplicationSessionRaw(requestParameters: GetApplicationSessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApplicationSession>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getApplicationSession().'
            );
        }

        if (requestParameters['sessionId'] == null) {
            throw new runtime.RequiredError(
                'sessionId',
                'Required parameter "sessionId" was null or undefined when calling getApplicationSession().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/sessions/{sessionId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"sessionId"}}`, encodeURIComponent(String(requestParameters['sessionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationSessionFromJSON(jsonValue));
    }

    /**
     * Get the details of the given session. You can list the sessions with the [List Application sessions](https://docs.talon.one/management-api#tag/Customer-data/operation/getApplicationSessions) endpoint. 
     * Get Application session
     */
    async getApplicationSession(requestParameters: GetApplicationSessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApplicationSession> {
        const response = await this.getApplicationSessionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all the sessions of the specified Application. 
     * List Application sessions
     */
    async getApplicationSessionsRaw(requestParameters: GetApplicationSessionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetApplicationSessions200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getApplicationSessions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['profile'] != null) {
            queryParameters['profile'] = requestParameters['profile'];
        }

        if (requestParameters['state'] != null) {
            queryParameters['state'] = requestParameters['state'];
        }

        if (requestParameters['createdBefore'] != null) {
            queryParameters['createdBefore'] = (requestParameters['createdBefore'] as any).toISOString();
        }

        if (requestParameters['createdAfter'] != null) {
            queryParameters['createdAfter'] = (requestParameters['createdAfter'] as any).toISOString();
        }

        if (requestParameters['coupon'] != null) {
            queryParameters['coupon'] = requestParameters['coupon'];
        }

        if (requestParameters['referral'] != null) {
            queryParameters['referral'] = requestParameters['referral'];
        }

        if (requestParameters['integrationId'] != null) {
            queryParameters['integrationId'] = requestParameters['integrationId'];
        }

        if (requestParameters['storeIntegrationId'] != null) {
            queryParameters['storeIntegrationId'] = requestParameters['storeIntegrationId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/sessions`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetApplicationSessions200ResponseFromJSON(jsonValue));
    }

    /**
     * List all the sessions of the specified Application. 
     * List Application sessions
     */
    async getApplicationSessions(requestParameters: GetApplicationSessionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetApplicationSessions200Response> {
        const response = await this.getApplicationSessionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all applications in the current account.
     * List Applications
     */
    async getApplicationsRaw(requestParameters: GetApplicationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetApplications200Response>> {
        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetApplications200ResponseFromJSON(jsonValue));
    }

    /**
     * List all applications in the current account.
     * List Applications
     */
    async getApplications(requestParameters: GetApplicationsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetApplications200Response> {
        const response = await this.getApplicationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the specified custom attribute. 
     * Get custom attribute
     */
    async getAttributeRaw(requestParameters: GetAttributeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Attribute>> {
        if (requestParameters['attributeId'] == null) {
            throw new runtime.RequiredError(
                'attributeId',
                'Required parameter "attributeId" was null or undefined when calling getAttribute().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/attributes/{attributeId}`;
        urlPath = urlPath.replace(`{${"attributeId"}}`, encodeURIComponent(String(requestParameters['attributeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AttributeFromJSON(jsonValue));
    }

    /**
     * Retrieve the specified custom attribute. 
     * Get custom attribute
     */
    async getAttribute(requestParameters: GetAttributeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Attribute> {
        const response = await this.getAttributeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return all the custom attributes for the account. 
     * List custom attributes
     */
    async getAttributesRaw(requestParameters: GetAttributesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAttributes200Response>> {
        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['entity'] != null) {
            queryParameters['entity'] = requestParameters['entity'];
        }

        if (requestParameters['applicationIds'] != null) {
            queryParameters['applicationIds'] = requestParameters['applicationIds'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['kind'] != null) {
            queryParameters['kind'] = requestParameters['kind'];
        }

        if (requestParameters['search'] != null) {
            queryParameters['search'] = requestParameters['search'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/attributes`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetAttributes200ResponseFromJSON(jsonValue));
    }

    /**
     * Return all the custom attributes for the account. 
     * List custom attributes
     */
    async getAttributes(requestParameters: GetAttributesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAttributes200Response> {
        const response = await this.getAttributesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a paginated list of the customer profiles in a given audience.  A maximum of 1000 customer profiles per page is allowed. 
     * List audience members
     */
    async getAudienceMembershipsRaw(requestParameters: GetAudienceMembershipsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAudienceMemberships200Response>> {
        if (requestParameters['audienceId'] == null) {
            throw new runtime.RequiredError(
                'audienceId',
                'Required parameter "audienceId" was null or undefined when calling getAudienceMemberships().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['profileQuery'] != null) {
            queryParameters['profileQuery'] = requestParameters['profileQuery'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/audiences/{audienceId}/memberships`;
        urlPath = urlPath.replace(`{${"audienceId"}}`, encodeURIComponent(String(requestParameters['audienceId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetAudienceMemberships200ResponseFromJSON(jsonValue));
    }

    /**
     * Get a paginated list of the customer profiles in a given audience.  A maximum of 1000 customer profiles per page is allowed. 
     * List audience members
     */
    async getAudienceMemberships(requestParameters: GetAudienceMembershipsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAudienceMemberships200Response> {
        const response = await this.getAudienceMembershipsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all audiences created in the account. To create an audience, use [Create audience](https://docs.talon.one/integration-api#tag/Audiences/operation/createAudienceV2). 
     * List audiences
     */
    async getAudiencesRaw(requestParameters: GetAudiencesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAudiences200Response>> {
        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['withTotalResultSize'] != null) {
            queryParameters['withTotalResultSize'] = requestParameters['withTotalResultSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/audiences`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetAudiences200ResponseFromJSON(jsonValue));
    }

    /**
     * Get all audiences created in the account. To create an audience, use [Create audience](https://docs.talon.one/integration-api#tag/Audiences/operation/createAudienceV2). 
     * List audiences
     */
    async getAudiences(requestParameters: GetAudiencesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAudiences200Response> {
        const response = await this.getAudiencesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of audience IDs and their member count. 
     * List audience analytics
     */
    async getAudiencesAnalyticsRaw(requestParameters: GetAudiencesAnalyticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAudiencesAnalytics200Response>> {
        if (requestParameters['audienceIds'] == null) {
            throw new runtime.RequiredError(
                'audienceIds',
                'Required parameter "audienceIds" was null or undefined when calling getAudiencesAnalytics().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['audienceIds'] != null) {
            queryParameters['audienceIds'] = requestParameters['audienceIds'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/audiences/analytics`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetAudiencesAnalytics200ResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of audience IDs and their member count. 
     * List audience analytics
     */
    async getAudiencesAnalytics(requestParameters: GetAudiencesAnalyticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAudiencesAnalytics200Response> {
        const response = await this.getAudiencesAnalyticsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the given campaign.
     * Get campaign
     */
    async getCampaignRaw(requestParameters: GetCampaignRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Campaign>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getCampaign().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling getCampaign().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CampaignFromJSON(jsonValue));
    }

    /**
     * Retrieve the given campaign.
     * Get campaign
     */
    async getCampaign(requestParameters: GetCampaignRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Campaign> {
        const response = await this.getCampaignRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve statistical data about the performance of the given campaign.
     * Get analytics of campaigns
     */
    async getCampaignAnalyticsRaw(requestParameters: GetCampaignAnalyticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCampaignAnalytics200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getCampaignAnalytics().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling getCampaignAnalytics().'
            );
        }

        if (requestParameters['rangeStart'] == null) {
            throw new runtime.RequiredError(
                'rangeStart',
                'Required parameter "rangeStart" was null or undefined when calling getCampaignAnalytics().'
            );
        }

        if (requestParameters['rangeEnd'] == null) {
            throw new runtime.RequiredError(
                'rangeEnd',
                'Required parameter "rangeEnd" was null or undefined when calling getCampaignAnalytics().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['rangeStart'] != null) {
            queryParameters['rangeStart'] = (requestParameters['rangeStart'] as any).toISOString();
        }

        if (requestParameters['rangeEnd'] != null) {
            queryParameters['rangeEnd'] = (requestParameters['rangeEnd'] as any).toISOString();
        }

        if (requestParameters['granularity'] != null) {
            queryParameters['granularity'] = requestParameters['granularity'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/analytics`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetCampaignAnalytics200ResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve statistical data about the performance of the given campaign.
     * Get analytics of campaigns
     */
    async getCampaignAnalytics(requestParameters: GetCampaignAnalyticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCampaignAnalytics200Response> {
        const response = await this.getCampaignAnalyticsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all the campaigns that match a set of attributes. 
     * List campaigns that match the given attributes
     */
    async getCampaignByAttributesRaw(requestParameters: GetCampaignByAttributesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCampaigns200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getCampaignByAttributes().'
            );
        }

        if (requestParameters['campaignSearch'] == null) {
            throw new runtime.RequiredError(
                'campaignSearch',
                'Required parameter "campaignSearch" was null or undefined when calling getCampaignByAttributes().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['campaignState'] != null) {
            queryParameters['campaignState'] = requestParameters['campaignState'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns_search`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CampaignSearchToJSON(requestParameters['campaignSearch']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetCampaigns200ResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of all the campaigns that match a set of attributes. 
     * List campaigns that match the given attributes
     */
    async getCampaignByAttributes(requestParameters: GetCampaignByAttributesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCampaigns200Response> {
        const response = await this.getCampaignByAttributesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a campaign access group specified by its ID.
     * Get campaign access group
     */
    async getCampaignGroupRaw(requestParameters: GetCampaignGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CampaignGroup>> {
        if (requestParameters['campaignGroupId'] == null) {
            throw new runtime.RequiredError(
                'campaignGroupId',
                'Required parameter "campaignGroupId" was null or undefined when calling getCampaignGroup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/campaign_groups/{campaignGroupId}`;
        urlPath = urlPath.replace(`{${"campaignGroupId"}}`, encodeURIComponent(String(requestParameters['campaignGroupId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CampaignGroupFromJSON(jsonValue));
    }

    /**
     * Get a campaign access group specified by its ID.
     * Get campaign access group
     */
    async getCampaignGroup(requestParameters: GetCampaignGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CampaignGroup> {
        const response = await this.getCampaignGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List the campaign access groups in the current account.
     * List campaign access groups
     */
    async getCampaignGroupsRaw(requestParameters: GetCampaignGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCampaignGroups200Response>> {
        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/campaign_groups`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetCampaignGroups200ResponseFromJSON(jsonValue));
    }

    /**
     * List the campaign access groups in the current account.
     * List campaign access groups
     */
    async getCampaignGroups(requestParameters: GetCampaignGroupsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCampaignGroups200Response> {
        const response = await this.getCampaignGroupsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of campaign templates.
     * List campaign templates
     */
    async getCampaignTemplatesRaw(requestParameters: GetCampaignTemplatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCampaignTemplates200Response>> {
        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['state'] != null) {
            queryParameters['state'] = requestParameters['state'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['tags'] != null) {
            queryParameters['tags'] = requestParameters['tags'];
        }

        if (requestParameters['userId'] != null) {
            queryParameters['userId'] = requestParameters['userId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/campaign_templates`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetCampaignTemplates200ResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of campaign templates.
     * List campaign templates
     */
    async getCampaignTemplates(requestParameters: GetCampaignTemplatesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCampaignTemplates200Response> {
        const response = await this.getCampaignTemplatesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List the campaigns of the specified application that match your filter criteria. 
     * List campaigns
     */
    async getCampaignsRaw(requestParameters: GetCampaignsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCampaigns200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getCampaigns().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['campaignState'] != null) {
            queryParameters['campaignState'] = requestParameters['campaignState'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['tags'] != null) {
            queryParameters['tags'] = requestParameters['tags'];
        }

        if (requestParameters['createdBefore'] != null) {
            queryParameters['createdBefore'] = (requestParameters['createdBefore'] as any).toISOString();
        }

        if (requestParameters['createdAfter'] != null) {
            queryParameters['createdAfter'] = (requestParameters['createdAfter'] as any).toISOString();
        }

        if (requestParameters['startBefore'] != null) {
            queryParameters['startBefore'] = (requestParameters['startBefore'] as any).toISOString();
        }

        if (requestParameters['startAfter'] != null) {
            queryParameters['startAfter'] = (requestParameters['startAfter'] as any).toISOString();
        }

        if (requestParameters['endBefore'] != null) {
            queryParameters['endBefore'] = (requestParameters['endBefore'] as any).toISOString();
        }

        if (requestParameters['endAfter'] != null) {
            queryParameters['endAfter'] = (requestParameters['endAfter'] as any).toISOString();
        }

        if (requestParameters['campaignGroupId'] != null) {
            queryParameters['campaignGroupId'] = requestParameters['campaignGroupId'];
        }

        if (requestParameters['templateId'] != null) {
            queryParameters['templateId'] = requestParameters['templateId'];
        }

        if (requestParameters['storeId'] != null) {
            queryParameters['storeId'] = requestParameters['storeId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetCampaigns200ResponseFromJSON(jsonValue));
    }

    /**
     * List the campaigns of the specified application that match your filter criteria. 
     * List campaigns
     */
    async getCampaigns(requestParameters: GetCampaignsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCampaigns200Response> {
        const response = await this.getCampaignsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the audit logs displayed in **Accounts > Audit logs**. 
     * Get audit logs for an account
     */
    async getChangesRaw(requestParameters: GetChangesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetChanges200Response>> {
        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['applicationId'] != null) {
            queryParameters['applicationId'] = requestParameters['applicationId'];
        }

        if (requestParameters['entityPath'] != null) {
            queryParameters['entityPath'] = requestParameters['entityPath'];
        }

        if (requestParameters['userId'] != null) {
            queryParameters['userId'] = requestParameters['userId'];
        }

        if (requestParameters['createdBefore'] != null) {
            queryParameters['createdBefore'] = (requestParameters['createdBefore'] as any).toISOString();
        }

        if (requestParameters['createdAfter'] != null) {
            queryParameters['createdAfter'] = (requestParameters['createdAfter'] as any).toISOString();
        }

        if (requestParameters['withTotalResultSize'] != null) {
            queryParameters['withTotalResultSize'] = requestParameters['withTotalResultSize'];
        }

        if (requestParameters['managementKeyId'] != null) {
            queryParameters['managementKeyId'] = requestParameters['managementKeyId'];
        }

        if (requestParameters['includeOld'] != null) {
            queryParameters['includeOld'] = requestParameters['includeOld'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/changes`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetChanges200ResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the audit logs displayed in **Accounts > Audit logs**. 
     * Get audit logs for an account
     */
    async getChanges(requestParameters: GetChangesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetChanges200Response> {
        const response = await this.getChangesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a given campaign-level collection.
     * Get campaign-level collection
     */
    async getCollectionRaw(requestParameters: GetCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Collection>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getCollection().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling getCollection().'
            );
        }

        if (requestParameters['collectionId'] == null) {
            throw new runtime.RequiredError(
                'collectionId',
                'Required parameter "collectionId" was null or undefined when calling getCollection().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/collections/{collectionId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));
        urlPath = urlPath.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters['collectionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CollectionFromJSON(jsonValue));
    }

    /**
     * Retrieve a given campaign-level collection.
     * Get campaign-level collection
     */
    async getCollection(requestParameters: GetCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Collection> {
        const response = await this.getCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve items from a given collection.  You can retrieve items from both account-level collections and campaign-level collections using this endpoint. 
     * Get collection items
     */
    async getCollectionItemsRaw(requestParameters: GetCollectionItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCollectionItems200Response>> {
        if (requestParameters['collectionId'] == null) {
            throw new runtime.RequiredError(
                'collectionId',
                'Required parameter "collectionId" was null or undefined when calling getCollectionItems().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/collections/{collectionId}/items`;
        urlPath = urlPath.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters['collectionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetCollectionItems200ResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve items from a given collection.  You can retrieve items from both account-level collections and campaign-level collections using this endpoint. 
     * Get collection items
     */
    async getCollectionItems(requestParameters: GetCollectionItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCollectionItems200Response> {
        const response = await this.getCollectionItemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all the coupons matching the specified criteria. 
     * List coupons
     */
    async getCouponsWithoutTotalCountRaw(requestParameters: GetCouponsWithoutTotalCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCouponsWithoutTotalCount200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getCouponsWithoutTotalCount().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling getCouponsWithoutTotalCount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['value'] != null) {
            queryParameters['value'] = requestParameters['value'];
        }

        if (requestParameters['createdBefore'] != null) {
            queryParameters['createdBefore'] = (requestParameters['createdBefore'] as any).toISOString();
        }

        if (requestParameters['createdAfter'] != null) {
            queryParameters['createdAfter'] = (requestParameters['createdAfter'] as any).toISOString();
        }

        if (requestParameters['valid'] != null) {
            queryParameters['valid'] = requestParameters['valid'];
        }

        if (requestParameters['usable'] != null) {
            queryParameters['usable'] = requestParameters['usable'];
        }

        if (requestParameters['redeemed'] != null) {
            queryParameters['redeemed'] = requestParameters['redeemed'];
        }

        if (requestParameters['referralId'] != null) {
            queryParameters['referralId'] = requestParameters['referralId'];
        }

        if (requestParameters['recipientIntegrationId'] != null) {
            queryParameters['recipientIntegrationId'] = requestParameters['recipientIntegrationId'];
        }

        if (requestParameters['batchId'] != null) {
            queryParameters['batchId'] = requestParameters['batchId'];
        }

        if (requestParameters['exactMatch'] != null) {
            queryParameters['exactMatch'] = requestParameters['exactMatch'];
        }

        if (requestParameters['expiresBefore'] != null) {
            queryParameters['expiresBefore'] = (requestParameters['expiresBefore'] as any).toISOString();
        }

        if (requestParameters['expiresAfter'] != null) {
            queryParameters['expiresAfter'] = (requestParameters['expiresAfter'] as any).toISOString();
        }

        if (requestParameters['startsBefore'] != null) {
            queryParameters['startsBefore'] = (requestParameters['startsBefore'] as any).toISOString();
        }

        if (requestParameters['startsAfter'] != null) {
            queryParameters['startsAfter'] = (requestParameters['startsAfter'] as any).toISOString();
        }

        if (requestParameters['valuesOnly'] != null) {
            queryParameters['valuesOnly'] = requestParameters['valuesOnly'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/coupons/no_total`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetCouponsWithoutTotalCount200ResponseFromJSON(jsonValue));
    }

    /**
     * List all the coupons matching the specified criteria. 
     * List coupons
     */
    async getCouponsWithoutTotalCount(requestParameters: GetCouponsWithoutTotalCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCouponsWithoutTotalCount200Response> {
        const response = await this.getCouponsWithoutTotalCountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch the summary report of a given customer in the given application, in a time range.
     * Get customer\'s activity report
     */
    async getCustomerActivityReportRaw(requestParameters: GetCustomerActivityReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CustomerActivityReport>> {
        if (requestParameters['rangeStart'] == null) {
            throw new runtime.RequiredError(
                'rangeStart',
                'Required parameter "rangeStart" was null or undefined when calling getCustomerActivityReport().'
            );
        }

        if (requestParameters['rangeEnd'] == null) {
            throw new runtime.RequiredError(
                'rangeEnd',
                'Required parameter "rangeEnd" was null or undefined when calling getCustomerActivityReport().'
            );
        }

        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getCustomerActivityReport().'
            );
        }

        if (requestParameters['customerId'] == null) {
            throw new runtime.RequiredError(
                'customerId',
                'Required parameter "customerId" was null or undefined when calling getCustomerActivityReport().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['rangeStart'] != null) {
            queryParameters['rangeStart'] = (requestParameters['rangeStart'] as any).toISOString();
        }

        if (requestParameters['rangeEnd'] != null) {
            queryParameters['rangeEnd'] = (requestParameters['rangeEnd'] as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/customer_activity_reports/{customerId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"customerId"}}`, encodeURIComponent(String(requestParameters['customerId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerActivityReportFromJSON(jsonValue));
    }

    /**
     * Fetch the summary report of a given customer in the given application, in a time range.
     * Get customer\'s activity report
     */
    async getCustomerActivityReport(requestParameters: GetCustomerActivityReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CustomerActivityReport> {
        const response = await this.getCustomerActivityReportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch summary reports for all application customers based on a time range. Instead of having the total number of results in the response, this endpoint only mentions whether there are more results. 
     * Get Activity Reports for Application Customers
     */
    async getCustomerActivityReportsWithoutTotalCountRaw(requestParameters: GetCustomerActivityReportsWithoutTotalCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCustomerActivityReportsWithoutTotalCount200Response>> {
        if (requestParameters['rangeStart'] == null) {
            throw new runtime.RequiredError(
                'rangeStart',
                'Required parameter "rangeStart" was null or undefined when calling getCustomerActivityReportsWithoutTotalCount().'
            );
        }

        if (requestParameters['rangeEnd'] == null) {
            throw new runtime.RequiredError(
                'rangeEnd',
                'Required parameter "rangeEnd" was null or undefined when calling getCustomerActivityReportsWithoutTotalCount().'
            );
        }

        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getCustomerActivityReportsWithoutTotalCount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['rangeStart'] != null) {
            queryParameters['rangeStart'] = (requestParameters['rangeStart'] as any).toISOString();
        }

        if (requestParameters['rangeEnd'] != null) {
            queryParameters['rangeEnd'] = (requestParameters['rangeEnd'] as any).toISOString();
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['integrationId'] != null) {
            queryParameters['integrationId'] = requestParameters['integrationId'];
        }

        if (requestParameters['campaignName'] != null) {
            queryParameters['campaignName'] = requestParameters['campaignName'];
        }

        if (requestParameters['advocateName'] != null) {
            queryParameters['advocateName'] = requestParameters['advocateName'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/customer_activity_reports/no_total`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetCustomerActivityReportsWithoutTotalCount200ResponseFromJSON(jsonValue));
    }

    /**
     * Fetch summary reports for all application customers based on a time range. Instead of having the total number of results in the response, this endpoint only mentions whether there are more results. 
     * Get Activity Reports for Application Customers
     */
    async getCustomerActivityReportsWithoutTotalCount(requestParameters: GetCustomerActivityReportsWithoutTotalCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCustomerActivityReportsWithoutTotalCount200Response> {
        const response = await this.getCustomerActivityReportsWithoutTotalCountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch analytics for a given customer in the given application.
     * Get customer\'s analytics report
     */
    async getCustomerAnalyticsRaw(requestParameters: GetCustomerAnalyticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CustomerAnalytics>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getCustomerAnalytics().'
            );
        }

        if (requestParameters['customerId'] == null) {
            throw new runtime.RequiredError(
                'customerId',
                'Required parameter "customerId" was null or undefined when calling getCustomerAnalytics().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/customers/{customerId}/analytics`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"customerId"}}`, encodeURIComponent(String(requestParameters['customerId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerAnalyticsFromJSON(jsonValue));
    }

    /**
     * Fetch analytics for a given customer in the given application.
     * Get customer\'s analytics report
     */
    async getCustomerAnalytics(requestParameters: GetCustomerAnalyticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CustomerAnalytics> {
        const response = await this.getCustomerAnalyticsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the details of the specified customer profile.  <div class=\"redoc-section\">   <p class=\"title\">Performance tips</p>    You can retrieve the same information via the Integration API, which can save you extra API requests. consider these options:    - Request the customer profile to be part of the response content using     [Update Customer Session](https://docs.talon.one/integration-api#tag/Customer-sessions/operation/updateCustomerSessionV2).   - Send an empty update with the [Update Customer Profile](https://docs.talon.one/integration-api#tag/Customer-profiles/operation/updateCustomerProfileV2) endpoint with `runRuleEngine=false`. </div> 
     * Get customer profile
     */
    async getCustomerProfileRaw(requestParameters: GetCustomerProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CustomerProfile>> {
        if (requestParameters['customerId'] == null) {
            throw new runtime.RequiredError(
                'customerId',
                'Required parameter "customerId" was null or undefined when calling getCustomerProfile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/customers/{customerId}`;
        urlPath = urlPath.replace(`{${"customerId"}}`, encodeURIComponent(String(requestParameters['customerId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomerProfileFromJSON(jsonValue));
    }

    /**
     * Return the details of the specified customer profile.  <div class=\"redoc-section\">   <p class=\"title\">Performance tips</p>    You can retrieve the same information via the Integration API, which can save you extra API requests. consider these options:    - Request the customer profile to be part of the response content using     [Update Customer Session](https://docs.talon.one/integration-api#tag/Customer-sessions/operation/updateCustomerSessionV2).   - Send an empty update with the [Update Customer Profile](https://docs.talon.one/integration-api#tag/Customer-profiles/operation/updateCustomerProfileV2) endpoint with `runRuleEngine=false`. </div> 
     * Get customer profile
     */
    async getCustomerProfile(requestParameters: GetCustomerProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CustomerProfile> {
        const response = await this.getCustomerProfileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * For the given customer profile, list all the achievements that match your filter criteria. 
     * List customer achievements
     */
    async getCustomerProfileAchievementProgressRaw(requestParameters: GetCustomerProfileAchievementProgressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCustomerProfileAchievementProgress200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getCustomerProfileAchievementProgress().'
            );
        }

        if (requestParameters['integrationId'] == null) {
            throw new runtime.RequiredError(
                'integrationId',
                'Required parameter "integrationId" was null or undefined when calling getCustomerProfileAchievementProgress().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['achievementId'] != null) {
            queryParameters['achievementId'] = requestParameters['achievementId'];
        }

        if (requestParameters['title'] != null) {
            queryParameters['title'] = requestParameters['title'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/achievement_progress/{integrationId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"integrationId"}}`, encodeURIComponent(String(requestParameters['integrationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetCustomerProfileAchievementProgress200ResponseFromJSON(jsonValue));
    }

    /**
     * For the given customer profile, list all the achievements that match your filter criteria. 
     * List customer achievements
     */
    async getCustomerProfileAchievementProgress(requestParameters: GetCustomerProfileAchievementProgressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCustomerProfileAchievementProgress200Response> {
        const response = await this.getCustomerProfileAchievementProgressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all customer profiles.
     * List customer profiles
     */
    async getCustomerProfilesRaw(requestParameters: GetCustomerProfilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCustomerProfiles200Response>> {
        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sandbox'] != null) {
            queryParameters['sandbox'] = requestParameters['sandbox'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/customers/no_total`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetCustomerProfiles200ResponseFromJSON(jsonValue));
    }

    /**
     * List all customer profiles.
     * List customer profiles
     */
    async getCustomerProfiles(requestParameters: GetCustomerProfilesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCustomerProfiles200Response> {
        const response = await this.getCustomerProfilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of the customer profiles matching the provided criteria.  The match is successful if all the attributes of the request are found in a profile, even if the profile has more attributes that are not present on the request. 
     * List customer profiles matching the given attributes
     */
    async getCustomersByAttributesRaw(requestParameters: GetCustomersByAttributesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCustomersByAttributes200Response>> {
        if (requestParameters['customerProfileSearchQuery'] == null) {
            throw new runtime.RequiredError(
                'customerProfileSearchQuery',
                'Required parameter "customerProfileSearchQuery" was null or undefined when calling getCustomersByAttributes().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sandbox'] != null) {
            queryParameters['sandbox'] = requestParameters['sandbox'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/customer_search/no_total`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomerProfileSearchQueryToJSON(requestParameters['customerProfileSearchQuery']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetCustomersByAttributes200ResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of the customer profiles matching the provided criteria.  The match is successful if all the attributes of the request are found in a profile, even if the profile has more attributes that are not present on the request. 
     * List customer profiles matching the given attributes
     */
    async getCustomersByAttributes(requestParameters: GetCustomersByAttributesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCustomersByAttributes200Response> {
        const response = await this.getCustomersByAttributesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the statistics displayed on the specified loyalty program\'s dashboard, such as the total active points, pending points, spent points, and expired points.  **Important:** The returned data does not include the current day. All statistics are updated daily at 11:59 PM in the loyalty program time zone. 
     * Get statistics for loyalty dashboard
     */
    async getDashboardStatisticsRaw(requestParameters: GetDashboardStatisticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetDashboardStatistics200Response>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling getDashboardStatistics().'
            );
        }

        if (requestParameters['rangeStart'] == null) {
            throw new runtime.RequiredError(
                'rangeStart',
                'Required parameter "rangeStart" was null or undefined when calling getDashboardStatistics().'
            );
        }

        if (requestParameters['rangeEnd'] == null) {
            throw new runtime.RequiredError(
                'rangeEnd',
                'Required parameter "rangeEnd" was null or undefined when calling getDashboardStatistics().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['subledgerId'] != null) {
            queryParameters['subledgerId'] = requestParameters['subledgerId'];
        }

        if (requestParameters['rangeStart'] != null) {
            queryParameters['rangeStart'] = (requestParameters['rangeStart'] as any).toISOString();
        }

        if (requestParameters['rangeEnd'] != null) {
            queryParameters['rangeEnd'] = (requestParameters['rangeEnd'] as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/dashboard`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetDashboardStatistics200ResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the statistics displayed on the specified loyalty program\'s dashboard, such as the total active points, pending points, spent points, and expired points.  **Important:** The returned data does not include the current day. All statistics are updated daily at 11:59 PM in the loyalty program time zone. 
     * Get statistics for loyalty dashboard
     */
    async getDashboardStatistics(requestParameters: GetDashboardStatisticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetDashboardStatistics200Response> {
        const response = await this.getDashboardStatisticsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch all event type definitions for your account. 
     * List event types
     */
    async getEventTypesRaw(requestParameters: GetEventTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetEventTypes200Response>> {
        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['includeOldVersions'] != null) {
            queryParameters['includeOldVersions'] = requestParameters['includeOldVersions'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/event_types`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetEventTypes200ResponseFromJSON(jsonValue));
    }

    /**
     * Fetch all event type definitions for your account. 
     * List event types
     */
    async getEventTypes(requestParameters: GetEventTypesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetEventTypes200Response> {
        const response = await this.getEventTypesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all past exports 
     * Get exports
     */
    async getExportsRaw(requestParameters: GetExportsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetExports200Response>> {
        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['applicationId'] != null) {
            queryParameters['applicationId'] = requestParameters['applicationId'];
        }

        if (requestParameters['campaignId'] != null) {
            queryParameters['campaignId'] = requestParameters['campaignId'];
        }

        if (requestParameters['entity'] != null) {
            queryParameters['entity'] = requestParameters['entity'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/exports`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetExports200ResponseFromJSON(jsonValue));
    }

    /**
     * List all past exports 
     * Get exports
     */
    async getExports(requestParameters: GetExportsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetExports200Response> {
        const response = await this.getExportsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the given loyalty card.
     * Get loyalty card
     */
    async getLoyaltyCardRaw(requestParameters: GetLoyaltyCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoyaltyCard>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling getLoyaltyCard().'
            );
        }

        if (requestParameters['loyaltyCardId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyCardId',
                'Required parameter "loyaltyCardId" was null or undefined when calling getLoyaltyCard().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/cards/{loyaltyCardId}`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));
        urlPath = urlPath.replace(`{${"loyaltyCardId"}}`, encodeURIComponent(String(requestParameters['loyaltyCardId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LoyaltyCardFromJSON(jsonValue));
    }

    /**
     * Get the given loyalty card.
     * Get loyalty card
     */
    async getLoyaltyCard(requestParameters: GetLoyaltyCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoyaltyCard> {
        const response = await this.getLoyaltyCardRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the transaction logs for the given [loyalty card](https://docs.talon.one/docs/product/loyalty-programs/card-based/card-based-overview) within the specified [card-based loyalty program](https://docs.talon.one/docs/product/loyalty-programs/overview#loyalty-program-types) with filtering options applied. If no filtering options are applied, the last 50 loyalty transactions for the given loyalty card are returned. 
     * List card\'s transactions
     */
    async getLoyaltyCardTransactionLogsRaw(requestParameters: GetLoyaltyCardTransactionLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetLoyaltyCardTransactionLogs200Response>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling getLoyaltyCardTransactionLogs().'
            );
        }

        if (requestParameters['loyaltyCardId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyCardId',
                'Required parameter "loyaltyCardId" was null or undefined when calling getLoyaltyCardTransactionLogs().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['startDate'] != null) {
            queryParameters['startDate'] = (requestParameters['startDate'] as any).toISOString();
        }

        if (requestParameters['endDate'] != null) {
            queryParameters['endDate'] = (requestParameters['endDate'] as any).toISOString();
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['subledgerId'] != null) {
            queryParameters['subledgerId'] = requestParameters['subledgerId'];
        }

        if (requestParameters['customerSessionIDs'] != null) {
            queryParameters['customerSessionIDs'] = requestParameters['customerSessionIDs'];
        }

        if (requestParameters['transactionUUIDs'] != null) {
            queryParameters['transactionUUIDs'] = requestParameters['transactionUUIDs'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/cards/{loyaltyCardId}/logs`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));
        urlPath = urlPath.replace(`{${"loyaltyCardId"}}`, encodeURIComponent(String(requestParameters['loyaltyCardId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetLoyaltyCardTransactionLogs200ResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the transaction logs for the given [loyalty card](https://docs.talon.one/docs/product/loyalty-programs/card-based/card-based-overview) within the specified [card-based loyalty program](https://docs.talon.one/docs/product/loyalty-programs/overview#loyalty-program-types) with filtering options applied. If no filtering options are applied, the last 50 loyalty transactions for the given loyalty card are returned. 
     * List card\'s transactions
     */
    async getLoyaltyCardTransactionLogs(requestParameters: GetLoyaltyCardTransactionLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetLoyaltyCardTransactionLogs200Response> {
        const response = await this.getLoyaltyCardTransactionLogsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * For the given card-based loyalty program, list the loyalty cards that match your filter criteria. 
     * List loyalty cards
     */
    async getLoyaltyCardsRaw(requestParameters: GetLoyaltyCardsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetLoyaltyCards200Response>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling getLoyaltyCards().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['identifier'] != null) {
            queryParameters['identifier'] = requestParameters['identifier'];
        }

        if (requestParameters['profileId'] != null) {
            queryParameters['profileId'] = requestParameters['profileId'];
        }

        if (requestParameters['batchId'] != null) {
            queryParameters['batchId'] = requestParameters['batchId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/cards`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetLoyaltyCards200ResponseFromJSON(jsonValue));
    }

    /**
     * For the given card-based loyalty program, list the loyalty cards that match your filter criteria. 
     * List loyalty cards
     */
    async getLoyaltyCards(requestParameters: GetLoyaltyCardsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetLoyaltyCards200Response> {
        const response = await this.getLoyaltyCardsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve loyalty ledger balances for the given Integration ID in the specified loyalty program. You can filter balances by date and subledger ID, and include tier-related information in the response.  **Note**: If no filtering options are applied, you retrieve all loyalty balances on the current date for the given integration ID.  Loyalty balances are calculated when Talon.One receives your request using the points stored in our database, so retrieving a large number of balances at once can impact performance.  For more information, see: - [Managing card-based loyalty program data](https://docs.talon.one/docs/product/loyalty-programs/card-based/managing-loyalty-cards) - [Managing profile-based loyalty program data](https://docs.talon.one/docs/product/loyalty-programs/profile-based/managing-pb-lp-data) 
     * Get customer\'s loyalty balances
     */
    async getLoyaltyLedgerBalancesRaw(requestParameters: GetLoyaltyLedgerBalancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoyaltyBalancesWithTiers>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling getLoyaltyLedgerBalances().'
            );
        }

        if (requestParameters['integrationId'] == null) {
            throw new runtime.RequiredError(
                'integrationId',
                'Required parameter "integrationId" was null or undefined when calling getLoyaltyLedgerBalances().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['endDate'] != null) {
            queryParameters['endDate'] = (requestParameters['endDate'] as any).toISOString();
        }

        if (requestParameters['subledgerId'] != null) {
            queryParameters['subledgerId'] = requestParameters['subledgerId'];
        }

        if (requestParameters['includeTiers'] != null) {
            queryParameters['includeTiers'] = requestParameters['includeTiers'];
        }

        if (requestParameters['includeProjectedTier'] != null) {
            queryParameters['includeProjectedTier'] = requestParameters['includeProjectedTier'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/profile/{integrationId}/ledger_balances`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));
        urlPath = urlPath.replace(`{${"integrationId"}}`, encodeURIComponent(String(requestParameters['integrationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LoyaltyBalancesWithTiersFromJSON(jsonValue));
    }

    /**
     * Retrieve loyalty ledger balances for the given Integration ID in the specified loyalty program. You can filter balances by date and subledger ID, and include tier-related information in the response.  **Note**: If no filtering options are applied, you retrieve all loyalty balances on the current date for the given integration ID.  Loyalty balances are calculated when Talon.One receives your request using the points stored in our database, so retrieving a large number of balances at once can impact performance.  For more information, see: - [Managing card-based loyalty program data](https://docs.talon.one/docs/product/loyalty-programs/card-based/managing-loyalty-cards) - [Managing profile-based loyalty program data](https://docs.talon.one/docs/product/loyalty-programs/profile-based/managing-pb-lp-data) 
     * Get customer\'s loyalty balances
     */
    async getLoyaltyLedgerBalances(requestParameters: GetLoyaltyLedgerBalancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoyaltyBalancesWithTiers> {
        const response = await this.getLoyaltyLedgerBalancesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the loyalty ledger for this profile integration ID.  To get the `integrationId` of the profile from a `sessionId`, use the [Update customer session](https://docs.talon.one/integration-api#operation/updateCustomerSessionV2) endpoint.  **Important:** To get loyalty transaction logs for a given Integration ID in a loyalty program, we recommend using the Integration API\'s [Get customer\'s loyalty logs](https://docs.talon.one/integration-api#tag/Loyalty/operation/getLoyaltyProgramProfileTransactions). 
     * Get customer\'s full loyalty ledger
     * @deprecated
     */
    async getLoyaltyPointsRaw(requestParameters: GetLoyaltyPointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoyaltyLedger>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling getLoyaltyPoints().'
            );
        }

        if (requestParameters['integrationId'] == null) {
            throw new runtime.RequiredError(
                'integrationId',
                'Required parameter "integrationId" was null or undefined when calling getLoyaltyPoints().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/profile/{integrationId}`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));
        urlPath = urlPath.replace(`{${"integrationId"}}`, encodeURIComponent(String(requestParameters['integrationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LoyaltyLedgerFromJSON(jsonValue));
    }

    /**
     * Get the loyalty ledger for this profile integration ID.  To get the `integrationId` of the profile from a `sessionId`, use the [Update customer session](https://docs.talon.one/integration-api#operation/updateCustomerSessionV2) endpoint.  **Important:** To get loyalty transaction logs for a given Integration ID in a loyalty program, we recommend using the Integration API\'s [Get customer\'s loyalty logs](https://docs.talon.one/integration-api#tag/Loyalty/operation/getLoyaltyProgramProfileTransactions). 
     * Get customer\'s full loyalty ledger
     * @deprecated
     */
    async getLoyaltyPoints(requestParameters: GetLoyaltyPointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoyaltyLedger> {
        const response = await this.getLoyaltyPointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the specified [loyalty program](https://docs.talon.one/docs/product/loyalty-programs/overview). To list all loyalty programs in your Application, use [List loyalty programs](#operation/getLoyaltyPrograms).  To list the loyalty programs that a customer profile is part of, use the [List customer data](https://docs.talon.one/integration-api#tag/Customer-profiles/operation/getCustomerInventory) 
     * Get loyalty program
     */
    async getLoyaltyProgramRaw(requestParameters: GetLoyaltyProgramRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoyaltyProgram>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling getLoyaltyProgram().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LoyaltyProgramFromJSON(jsonValue));
    }

    /**
     * Get the specified [loyalty program](https://docs.talon.one/docs/product/loyalty-programs/overview). To list all loyalty programs in your Application, use [List loyalty programs](#operation/getLoyaltyPrograms).  To list the loyalty programs that a customer profile is part of, use the [List customer data](https://docs.talon.one/integration-api#tag/Customer-profiles/operation/getCustomerInventory) 
     * Get loyalty program
     */
    async getLoyaltyProgram(requestParameters: GetLoyaltyProgramRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoyaltyProgram> {
        const response = await this.getLoyaltyProgramRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve paginated results of loyalty transaction logs for the given Integration ID in the specified loyalty program.  You can filter transactions by date or by ledger (subledger or main ledger). If no filters are applied, the last 50 loyalty transactions for the given integration ID are returned.  **Note:** To retrieve all loyalty program transaction logs in a given loyalty program, use the [List loyalty program transactions](https://docs.talon.one/management-api#tag/Loyalty/operation/getLoyaltyProgramTransactions) endpoint. 
     * List customer\'s loyalty transactions
     */
    async getLoyaltyProgramProfileLedgerTransactionsRaw(requestParameters: GetLoyaltyProgramProfileLedgerTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetLoyaltyProgramProfileTransactions200Response>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling getLoyaltyProgramProfileLedgerTransactions().'
            );
        }

        if (requestParameters['integrationId'] == null) {
            throw new runtime.RequiredError(
                'integrationId',
                'Required parameter "integrationId" was null or undefined when calling getLoyaltyProgramProfileLedgerTransactions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['customerSessionIDs'] != null) {
            queryParameters['customerSessionIDs'] = requestParameters['customerSessionIDs'];
        }

        if (requestParameters['transactionUUIDs'] != null) {
            queryParameters['transactionUUIDs'] = requestParameters['transactionUUIDs'];
        }

        if (requestParameters['subledgerId'] != null) {
            queryParameters['subledgerId'] = requestParameters['subledgerId'];
        }

        if (requestParameters['loyaltyTransactionType'] != null) {
            queryParameters['loyaltyTransactionType'] = requestParameters['loyaltyTransactionType'];
        }

        if (requestParameters['startDate'] != null) {
            queryParameters['startDate'] = (requestParameters['startDate'] as any).toISOString();
        }

        if (requestParameters['endDate'] != null) {
            queryParameters['endDate'] = (requestParameters['endDate'] as any).toISOString();
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['awaitsActivation'] != null) {
            queryParameters['awaitsActivation'] = requestParameters['awaitsActivation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/profile/{integrationId}/ledger_transactions`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));
        urlPath = urlPath.replace(`{${"integrationId"}}`, encodeURIComponent(String(requestParameters['integrationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetLoyaltyProgramProfileTransactions200ResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve paginated results of loyalty transaction logs for the given Integration ID in the specified loyalty program.  You can filter transactions by date or by ledger (subledger or main ledger). If no filters are applied, the last 50 loyalty transactions for the given integration ID are returned.  **Note:** To retrieve all loyalty program transaction logs in a given loyalty program, use the [List loyalty program transactions](https://docs.talon.one/management-api#tag/Loyalty/operation/getLoyaltyProgramTransactions) endpoint. 
     * List customer\'s loyalty transactions
     */
    async getLoyaltyProgramProfileLedgerTransactions(requestParameters: GetLoyaltyProgramProfileLedgerTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetLoyaltyProgramProfileTransactions200Response> {
        const response = await this.getLoyaltyProgramProfileLedgerTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve loyalty program transaction logs in a given loyalty program with filtering options applied. Manual and imported transactions are also included. **Note:** If no filters are applied, the last 50 loyalty transactions for the given loyalty program are returned.  **Important:** To get loyalty transaction logs for a given Integration ID in a loyalty program, we recommend using the Integration API\'s [Get customer\'s loyalty logs](https://docs.talon.one/integration-api#tag/Loyalty/operation/getLoyaltyProgramProfileTransactions). 
     * List loyalty program transactions
     */
    async getLoyaltyProgramTransactionsRaw(requestParameters: GetLoyaltyProgramTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetLoyaltyProgramTransactions200Response>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling getLoyaltyProgramTransactions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['loyaltyTransactionType'] != null) {
            queryParameters['loyaltyTransactionType'] = requestParameters['loyaltyTransactionType'];
        }

        if (requestParameters['subledgerId'] != null) {
            queryParameters['subledgerId'] = requestParameters['subledgerId'];
        }

        if (requestParameters['customerSessionIDs'] != null) {
            queryParameters['customerSessionIDs'] = requestParameters['customerSessionIDs'];
        }

        if (requestParameters['transactionUUIDs'] != null) {
            queryParameters['transactionUUIDs'] = requestParameters['transactionUUIDs'];
        }

        if (requestParameters['startDate'] != null) {
            queryParameters['startDate'] = (requestParameters['startDate'] as any).toISOString();
        }

        if (requestParameters['endDate'] != null) {
            queryParameters['endDate'] = (requestParameters['endDate'] as any).toISOString();
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['awaitsActivation'] != null) {
            queryParameters['awaitsActivation'] = requestParameters['awaitsActivation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/transactions`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetLoyaltyProgramTransactions200ResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve loyalty program transaction logs in a given loyalty program with filtering options applied. Manual and imported transactions are also included. **Note:** If no filters are applied, the last 50 loyalty transactions for the given loyalty program are returned.  **Important:** To get loyalty transaction logs for a given Integration ID in a loyalty program, we recommend using the Integration API\'s [Get customer\'s loyalty logs](https://docs.talon.one/integration-api#tag/Loyalty/operation/getLoyaltyProgramProfileTransactions). 
     * List loyalty program transactions
     */
    async getLoyaltyProgramTransactions(requestParameters: GetLoyaltyProgramTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetLoyaltyProgramTransactions200Response> {
        const response = await this.getLoyaltyProgramTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List the loyalty programs of the account.
     * List loyalty programs
     */
    async getLoyaltyProgramsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetLoyaltyPrograms200Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetLoyaltyPrograms200ResponseFromJSON(jsonValue));
    }

    /**
     * List the loyalty programs of the account.
     * List loyalty programs
     */
    async getLoyaltyPrograms(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetLoyaltyPrograms200Response> {
        const response = await this.getLoyaltyProgramsRaw(initOverrides);
        return await response.value();
    }

    /**
     *  Deprecation notice: Support for requests to this endpoint will end soon. To retrieve statistics for a loyalty program, use the [Get statistics for loyalty dashboard](/management-api#tag/Loyalty/operation/getDashboardStatistics) endpoint.  Retrieve the statistics of the specified loyalty program, such as the total active points, pending points, spent points, and expired points. 
     * Get loyalty program statistics
     * @deprecated
     */
    async getLoyaltyStatisticsRaw(requestParameters: GetLoyaltyStatisticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoyaltyDashboardData>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling getLoyaltyStatistics().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/statistics`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LoyaltyDashboardDataFromJSON(jsonValue));
    }

    /**
     *  Deprecation notice: Support for requests to this endpoint will end soon. To retrieve statistics for a loyalty program, use the [Get statistics for loyalty dashboard](/management-api#tag/Loyalty/operation/getDashboardStatistics) endpoint.  Retrieve the statistics of the specified loyalty program, such as the total active points, pending points, spent points, and expired points. 
     * Get loyalty program statistics
     * @deprecated
     */
    async getLoyaltyStatistics(requestParameters: GetLoyaltyStatisticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoyaltyDashboardData> {
        const response = await this.getLoyaltyStatisticsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all message log entries.
     * List message log entries
     */
    async getMessageLogsRaw(requestParameters: GetMessageLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageLogEntries>> {
        if (requestParameters['entityType'] == null) {
            throw new runtime.RequiredError(
                'entityType',
                'Required parameter "entityType" was null or undefined when calling getMessageLogs().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['messageID'] != null) {
            queryParameters['messageID'] = requestParameters['messageID'];
        }

        if (requestParameters['changeType'] != null) {
            queryParameters['changeType'] = requestParameters['changeType'];
        }

        if (requestParameters['notificationIDs'] != null) {
            queryParameters['notificationIDs'] = requestParameters['notificationIDs'];
        }

        if (requestParameters['createdBefore'] != null) {
            queryParameters['createdBefore'] = (requestParameters['createdBefore'] as any).toISOString();
        }

        if (requestParameters['createdAfter'] != null) {
            queryParameters['createdAfter'] = (requestParameters['createdAfter'] as any).toISOString();
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['period'] != null) {
            queryParameters['period'] = requestParameters['period'];
        }

        if (requestParameters['isSuccessful'] != null) {
            queryParameters['isSuccessful'] = requestParameters['isSuccessful'];
        }

        if (requestParameters['entityType'] != null) {
            queryParameters['entityType'] = requestParameters['entityType'];
        }

        if (requestParameters['applicationId'] != null) {
            queryParameters['applicationId'] = requestParameters['applicationId'];
        }

        if (requestParameters['campaignId'] != null) {
            queryParameters['campaignId'] = requestParameters['campaignId'];
        }

        if (requestParameters['loyaltyProgramId'] != null) {
            queryParameters['loyaltyProgramId'] = requestParameters['loyaltyProgramId'];
        }

        if (requestParameters['responseCode'] != null) {
            queryParameters['responseCode'] = requestParameters['responseCode'];
        }

        if (requestParameters['webhookIDs'] != null) {
            queryParameters['webhookIDs'] = requestParameters['webhookIDs'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/message_logs`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MessageLogEntriesFromJSON(jsonValue));
    }

    /**
     * Retrieve all message log entries.
     * List message log entries
     */
    async getMessageLogs(requestParameters: GetMessageLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageLogEntries> {
        const response = await this.getMessageLogsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all referrals of the specified campaign.
     * List referrals
     */
    async getReferralsWithoutTotalCountRaw(requestParameters: GetReferralsWithoutTotalCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetReferralsWithoutTotalCount200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getReferralsWithoutTotalCount().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling getReferralsWithoutTotalCount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['code'] != null) {
            queryParameters['code'] = requestParameters['code'];
        }

        if (requestParameters['createdBefore'] != null) {
            queryParameters['createdBefore'] = (requestParameters['createdBefore'] as any).toISOString();
        }

        if (requestParameters['createdAfter'] != null) {
            queryParameters['createdAfter'] = (requestParameters['createdAfter'] as any).toISOString();
        }

        if (requestParameters['valid'] != null) {
            queryParameters['valid'] = requestParameters['valid'];
        }

        if (requestParameters['usable'] != null) {
            queryParameters['usable'] = requestParameters['usable'];
        }

        if (requestParameters['advocate'] != null) {
            queryParameters['advocate'] = requestParameters['advocate'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/referrals/no_total`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetReferralsWithoutTotalCount200ResponseFromJSON(jsonValue));
    }

    /**
     * List all referrals of the specified campaign.
     * List referrals
     */
    async getReferralsWithoutTotalCount(requestParameters: GetReferralsWithoutTotalCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetReferralsWithoutTotalCount200Response> {
        const response = await this.getReferralsWithoutTotalCountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the details of a specific role. To see all the roles, use the [List roles](/management-api#tag/Roles/operation/listAllRolesV2) endpoint. 
     * Get role
     */
    async getRoleV2Raw(requestParameters: GetRoleV2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RoleV2>> {
        if (requestParameters['roleId'] == null) {
            throw new runtime.RequiredError(
                'roleId',
                'Required parameter "roleId" was null or undefined when calling getRoleV2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v2/roles/{roleId}`;
        urlPath = urlPath.replace(`{${"roleId"}}`, encodeURIComponent(String(requestParameters['roleId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleV2FromJSON(jsonValue));
    }

    /**
     * Get the details of a specific role. To see all the roles, use the [List roles](/management-api#tag/Roles/operation/listAllRolesV2) endpoint. 
     * Get role
     */
    async getRoleV2(requestParameters: GetRoleV2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RoleV2> {
        const response = await this.getRoleV2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the specified ruleset.
     * Get ruleset
     */
    async getRulesetRaw(requestParameters: GetRulesetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Ruleset>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getRuleset().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling getRuleset().'
            );
        }

        if (requestParameters['rulesetId'] == null) {
            throw new runtime.RequiredError(
                'rulesetId',
                'Required parameter "rulesetId" was null or undefined when calling getRuleset().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets/{rulesetId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));
        urlPath = urlPath.replace(`{${"rulesetId"}}`, encodeURIComponent(String(requestParameters['rulesetId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RulesetFromJSON(jsonValue));
    }

    /**
     * Retrieve the specified ruleset.
     * Get ruleset
     */
    async getRuleset(requestParameters: GetRulesetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Ruleset> {
        const response = await this.getRulesetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all rulesets of this campaign. A ruleset is a revision of the rules of a campaign. **Important:** The response also includes deleted rules. You should only consider the latest revision of the returned rulesets. 
     * List campaign rulesets
     */
    async getRulesetsRaw(requestParameters: GetRulesetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRulesets200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getRulesets().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling getRulesets().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetRulesets200ResponseFromJSON(jsonValue));
    }

    /**
     * List all rulesets of this campaign. A ruleset is a revision of the rules of a campaign. **Important:** The response also includes deleted rules. You should only consider the latest revision of the returned rulesets. 
     * List campaign rulesets
     */
    async getRulesets(requestParameters: GetRulesetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRulesets200Response> {
        const response = await this.getRulesetsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get store details for a specific store ID.
     * Get store
     */
    async getStoreRaw(requestParameters: GetStoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Store>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling getStore().'
            );
        }

        if (requestParameters['storeId'] == null) {
            throw new runtime.RequiredError(
                'storeId',
                'Required parameter "storeId" was null or undefined when calling getStore().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/stores/{storeId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"storeId"}}`, encodeURIComponent(String(requestParameters['storeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreFromJSON(jsonValue));
    }

    /**
     * Get store details for a specific store ID.
     * Get store
     */
    async getStore(requestParameters: GetStoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Store> {
        const response = await this.getStoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the data (including an invitation code) for a user. Non-admin users can only get their own profile. 
     * Get user
     */
    async getUserRaw(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<User>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling getUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/users/{userId}`;
        urlPath = urlPath.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * Retrieve the data (including an invitation code) for a user. Non-admin users can only get their own profile. 
     * Get user
     */
    async getUser(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<User> {
        const response = await this.getUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all users in your account. 
     * List users in account
     */
    async getUsersRaw(requestParameters: GetUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetUsers200Response>> {
        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/users`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetUsers200ResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve all users in your account. 
     * List users in account
     */
    async getUsers(requestParameters: GetUsersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetUsers200Response> {
        const response = await this.getUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a webhook by its id.
     * Get webhook
     */
    async getWebhookRaw(requestParameters: GetWebhookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Webhook>> {
        if (requestParameters['webhookId'] == null) {
            throw new runtime.RequiredError(
                'webhookId',
                'Required parameter "webhookId" was null or undefined when calling getWebhook().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/webhooks/{webhookId}`;
        urlPath = urlPath.replace(`{${"webhookId"}}`, encodeURIComponent(String(requestParameters['webhookId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WebhookFromJSON(jsonValue));
    }

    /**
     * Returns a webhook by its id.
     * Get webhook
     */
    async getWebhook(requestParameters: GetWebhookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Webhook> {
        const response = await this.getWebhookRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all webhooks.
     * List webhooks
     */
    async getWebhooksRaw(requestParameters: GetWebhooksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetWebhooks200Response>> {
        const queryParameters: any = {};

        if (requestParameters['applicationIds'] != null) {
            queryParameters['applicationIds'] = requestParameters['applicationIds'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['creationType'] != null) {
            queryParameters['creationType'] = requestParameters['creationType'];
        }

        if (requestParameters['visibility'] != null) {
            queryParameters['visibility'] = requestParameters['visibility'];
        }

        if (requestParameters['outgoingIntegrationsTypeId'] != null) {
            queryParameters['outgoingIntegrationsTypeId'] = requestParameters['outgoingIntegrationsTypeId'];
        }

        if (requestParameters['title'] != null) {
            queryParameters['title'] = requestParameters['title'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/webhooks`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetWebhooks200ResponseFromJSON(jsonValue));
    }

    /**
     * List all webhooks.
     * List webhooks
     */
    async getWebhooks(requestParameters: GetWebhooksRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetWebhooks200Response> {
        const response = await this.getWebhooksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a CSV file containing the collection of string values that should be attached as payload for collection. The file should be sent as multipart data.  The import **replaces** the initial content of the collection.  The CSV file **must** only contain the following column:  - `item`: the values in your collection.  A collection is limited to 500,000 items.  Example:  ``` item Addidas Nike Asics ```  **Note:** Before sending a request to this endpoint, ensure the data in the CSV to import is different from the data currently stored in the collection. 
     * Import data into existing account-level collection
     */
    async importAccountCollectionRaw(requestParameters: ImportAccountCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Import>> {
        if (requestParameters['collectionId'] == null) {
            throw new runtime.RequiredError(
                'collectionId',
                'Required parameter "collectionId" was null or undefined when calling importAccountCollection().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['upFile'] != null) {
            formParams.append('upFile', requestParameters['upFile'] as any);
        }


        let urlPath = `/v1/collections/{collectionId}/import`;
        urlPath = urlPath.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters['collectionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportFromJSON(jsonValue));
    }

    /**
     * Upload a CSV file containing the collection of string values that should be attached as payload for collection. The file should be sent as multipart data.  The import **replaces** the initial content of the collection.  The CSV file **must** only contain the following column:  - `item`: the values in your collection.  A collection is limited to 500,000 items.  Example:  ``` item Addidas Nike Asics ```  **Note:** Before sending a request to this endpoint, ensure the data in the CSV to import is different from the data currently stored in the collection. 
     * Import data into existing account-level collection
     */
    async importAccountCollection(requestParameters: ImportAccountCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Import> {
        const response = await this.importAccountCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a CSV file containing a list of [picklist values](https://docs.talon.one/docs/product/account/dev-tools/managing-attributes#picklist-values) for the specified attribute.  The file should be sent as multipart data.  The import **replaces** the previous list of allowed values for this attribute, if any.  The CSV file **must** only contain the following column: - `item` (required): the values in your allowed list, for example a list of SKU\'s.  An allowed list is limited to 500,000 items.  Example:  ```text item CS-VG-04032021-UP-50D-10 CS-DV-04042021-UP-49D-12 CS-DG-02082021-UP-50G-07 ``` 
     * Import allowed values for attribute
     */
    async importAllowedListRaw(requestParameters: ImportAllowedListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Import>> {
        if (requestParameters['attributeId'] == null) {
            throw new runtime.RequiredError(
                'attributeId',
                'Required parameter "attributeId" was null or undefined when calling importAllowedList().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['upFile'] != null) {
            formParams.append('upFile', requestParameters['upFile'] as any);
        }


        let urlPath = `/v1/attributes/{attributeId}/allowed_list/import`;
        urlPath = urlPath.replace(`{${"attributeId"}}`, encodeURIComponent(String(requestParameters['attributeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportFromJSON(jsonValue));
    }

    /**
     * Upload a CSV file containing a list of [picklist values](https://docs.talon.one/docs/product/account/dev-tools/managing-attributes#picklist-values) for the specified attribute.  The file should be sent as multipart data.  The import **replaces** the previous list of allowed values for this attribute, if any.  The CSV file **must** only contain the following column: - `item` (required): the values in your allowed list, for example a list of SKU\'s.  An allowed list is limited to 500,000 items.  Example:  ```text item CS-VG-04032021-UP-50D-10 CS-DV-04042021-UP-49D-12 CS-DG-02082021-UP-50G-07 ``` 
     * Import allowed values for attribute
     */
    async importAllowedList(requestParameters: ImportAllowedListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Import> {
        const response = await this.importAllowedListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a CSV file containing the integration IDs of the members you want to add to an audience.  The file should be sent as multipart data and should contain only the following column (required): - `profileintegrationid`: The integration ID of the customer profile.  The import **replaces** the previous list of audience members.  **Note:** We recommend limiting your file size to 500MB.  Example:  ```text profileintegrationid charles alexa ``` 
     * Import audience members
     */
    async importAudiencesMembershipsRaw(requestParameters: ImportAudiencesMembershipsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Import>> {
        if (requestParameters['audienceId'] == null) {
            throw new runtime.RequiredError(
                'audienceId',
                'Required parameter "audienceId" was null or undefined when calling importAudiencesMemberships().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['upFile'] != null) {
            formParams.append('upFile', requestParameters['upFile'] as any);
        }


        let urlPath = `/v1/audiences/{audienceId}/memberships/import`;
        urlPath = urlPath.replace(`{${"audienceId"}}`, encodeURIComponent(String(requestParameters['audienceId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportFromJSON(jsonValue));
    }

    /**
     * Upload a CSV file containing the integration IDs of the members you want to add to an audience.  The file should be sent as multipart data and should contain only the following column (required): - `profileintegrationid`: The integration ID of the customer profile.  The import **replaces** the previous list of audience members.  **Note:** We recommend limiting your file size to 500MB.  Example:  ```text profileintegrationid charles alexa ``` 
     * Import audience members
     */
    async importAudiencesMemberships(requestParameters: ImportAudiencesMembershipsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Import> {
        const response = await this.importAudiencesMembershipsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a CSV file containing store budgets for a given campaign.  Send the file as multipart data.  The CSV file **must** only contain the following columns: - `store_integration_id`: The identifier of the store. - `limit`: The budget limit for the store.  The import **replaces** the previous list of store budgets. 
     * Import campaign store budgets
     */
    async importCampaignStoreBudgetRaw(requestParameters: ImportCampaignStoreBudgetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Import>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling importCampaignStoreBudget().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling importCampaignStoreBudget().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['action'] != null) {
            queryParameters['action'] = requestParameters['action'];
        }

        if (requestParameters['period'] != null) {
            queryParameters['period'] = requestParameters['period'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['upFile'] != null) {
            formParams.append('upFile', requestParameters['upFile'] as any);
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/stores/budgets/import`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportFromJSON(jsonValue));
    }

    /**
     * Upload a CSV file containing store budgets for a given campaign.  Send the file as multipart data.  The CSV file **must** only contain the following columns: - `store_integration_id`: The identifier of the store. - `limit`: The budget limit for the store.  The import **replaces** the previous list of store budgets. 
     * Import campaign store budgets
     */
    async importCampaignStoreBudget(requestParameters: ImportCampaignStoreBudgetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Import> {
        const response = await this.importCampaignStoreBudgetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a CSV file containing the stores you want to link to a specific campaign.  Send the file as multipart data.  The CSV file **must** only contain the following column: - `store_integration_id`: The identifier of the store.  The import **replaces** the previous list of stores linked to the campaign. 
     * Import stores
     */
    async importCampaignStoresRaw(requestParameters: ImportCampaignStoresRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Import>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling importCampaignStores().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling importCampaignStores().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['upFile'] != null) {
            formParams.append('upFile', requestParameters['upFile'] as any);
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/stores/import`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportFromJSON(jsonValue));
    }

    /**
     * Upload a CSV file containing the stores you want to link to a specific campaign.  Send the file as multipart data.  The CSV file **must** only contain the following column: - `store_integration_id`: The identifier of the store.  The import **replaces** the previous list of stores linked to the campaign. 
     * Import stores
     */
    async importCampaignStores(requestParameters: ImportCampaignStoresRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Import> {
        const response = await this.importCampaignStoresRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a CSV file containing the collection of string values that should be attached as payload for collection. The file should be sent as multipart data.  The import **replaces** the initial content of the collection.  The CSV file **must** only contain the following column:  - `item`: the values in your collection.  A collection is limited to 500,000 items.  Example:  ``` item Addidas Nike Asics ```  **Note:** Before sending a request to this endpoint, ensure the data in the CSV to import is different from the data currently stored in the collection. 
     * Import data into existing campaign-level collection
     */
    async importCollectionRaw(requestParameters: ImportCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Import>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling importCollection().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling importCollection().'
            );
        }

        if (requestParameters['collectionId'] == null) {
            throw new runtime.RequiredError(
                'collectionId',
                'Required parameter "collectionId" was null or undefined when calling importCollection().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['upFile'] != null) {
            formParams.append('upFile', requestParameters['upFile'] as any);
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/collections/{collectionId}/import`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));
        urlPath = urlPath.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters['collectionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportFromJSON(jsonValue));
    }

    /**
     * Upload a CSV file containing the collection of string values that should be attached as payload for collection. The file should be sent as multipart data.  The import **replaces** the initial content of the collection.  The CSV file **must** only contain the following column:  - `item`: the values in your collection.  A collection is limited to 500,000 items.  Example:  ``` item Addidas Nike Asics ```  **Note:** Before sending a request to this endpoint, ensure the data in the CSV to import is different from the data currently stored in the collection. 
     * Import data into existing campaign-level collection
     */
    async importCollection(requestParameters: ImportCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Import> {
        const response = await this.importCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a CSV file containing the coupons that should be created. The file should be sent as multipart data.  The CSV file contains the following columns:  - `value` (required): The coupon code. - `expirydate`: The end date in RFC3339 of the code redemption period. - `startdate`: The start date in RFC3339 of the code redemption period. - `recipientintegrationid`: The integration ID of the recipient of the coupon.   Only the customer with this integration ID can redeem this code. Available only for personal codes. - `limitval`: The maximum number of redemptions of this code. For unlimited redemptions, use `0`. Defaults to `1` when not provided. - `discountlimit`: The total discount value that the code can give. This is typically used to represent a gift card value. - `attributes`: A JSON object describing _custom_ coupon attribute names and their values, enclosed with double quotation marks.    For example, if you created a [custom attribute](https://docs.talon.one/docs/dev/concepts/attributes#custom-attributes)   called `category` associated with the coupon entity, the object in the CSV file, when opened in a text editor, must be: `\"{\"category\": \"10_off\"}\"`.  You can use the time zone of your choice. It is converted to UTC internally by Talon.One.  **Note:** We recommend limiting your file size to 500MB.  **Example:**  ```text \"value\",\"expirydate\",\"startdate\",\"recipientintegrationid\",\"limitval\",\"attributes\",\"discountlimit\" COUP1,2018-07-01T04:00:00Z,2018-05-01T04:00:00Z,cust123,1,\"{\"\"Category\"\": \"\"10_off\"\"}\",2.4 ```  Once imported, you can find the `batchId` in the Campaign Manager or by using [List coupons](#tag/Coupons/operation/getCouponsWithoutTotalCount). 
     * Import coupons
     */
    async importCouponsRaw(requestParameters: ImportCouponsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Import>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling importCoupons().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling importCoupons().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['skipDuplicates'] != null) {
            queryParameters['skipDuplicates'] = requestParameters['skipDuplicates'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['upFile'] != null) {
            formParams.append('upFile', requestParameters['upFile'] as any);
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/import_coupons`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportFromJSON(jsonValue));
    }

    /**
     * Upload a CSV file containing the coupons that should be created. The file should be sent as multipart data.  The CSV file contains the following columns:  - `value` (required): The coupon code. - `expirydate`: The end date in RFC3339 of the code redemption period. - `startdate`: The start date in RFC3339 of the code redemption period. - `recipientintegrationid`: The integration ID of the recipient of the coupon.   Only the customer with this integration ID can redeem this code. Available only for personal codes. - `limitval`: The maximum number of redemptions of this code. For unlimited redemptions, use `0`. Defaults to `1` when not provided. - `discountlimit`: The total discount value that the code can give. This is typically used to represent a gift card value. - `attributes`: A JSON object describing _custom_ coupon attribute names and their values, enclosed with double quotation marks.    For example, if you created a [custom attribute](https://docs.talon.one/docs/dev/concepts/attributes#custom-attributes)   called `category` associated with the coupon entity, the object in the CSV file, when opened in a text editor, must be: `\"{\"category\": \"10_off\"}\"`.  You can use the time zone of your choice. It is converted to UTC internally by Talon.One.  **Note:** We recommend limiting your file size to 500MB.  **Example:**  ```text \"value\",\"expirydate\",\"startdate\",\"recipientintegrationid\",\"limitval\",\"attributes\",\"discountlimit\" COUP1,2018-07-01T04:00:00Z,2018-05-01T04:00:00Z,cust123,1,\"{\"\"Category\"\": \"\"10_off\"\"}\",2.4 ```  Once imported, you can find the `batchId` in the Campaign Manager or by using [List coupons](#tag/Coupons/operation/getCouponsWithoutTotalCount). 
     * Import coupons
     */
    async importCoupons(requestParameters: ImportCouponsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Import> {
        const response = await this.importCouponsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a CSV file containing the loyalty cards that you want to use in your card-based loyalty program. Send the file as multipart data.  It contains the following columns for each card:  - `identifier` (required): The alphanumeric identifier of the loyalty card. - `state` (required): The state of the loyalty card. It can be `active` or `inactive`. - `customerprofileids` (optional): An array of strings representing the identifiers of the customer profiles linked to the loyalty card. The identifiers should be separated with a semicolon (;).  **Note:** We recommend limiting your file size to 500MB.  **Example:**  ```csv identifier,state,customerprofileids 123-456-789AT,active,Alexa001;UserA ``` 
     * Import loyalty cards
     */
    async importLoyaltyCardsRaw(requestParameters: ImportLoyaltyCardsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Import>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling importLoyaltyCards().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['upFile'] != null) {
            formParams.append('upFile', requestParameters['upFile'] as any);
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/import_cards`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportFromJSON(jsonValue));
    }

    /**
     * Upload a CSV file containing the loyalty cards that you want to use in your card-based loyalty program. Send the file as multipart data.  It contains the following columns for each card:  - `identifier` (required): The alphanumeric identifier of the loyalty card. - `state` (required): The state of the loyalty card. It can be `active` or `inactive`. - `customerprofileids` (optional): An array of strings representing the identifiers of the customer profiles linked to the loyalty card. The identifiers should be separated with a semicolon (;).  **Note:** We recommend limiting your file size to 500MB.  **Example:**  ```csv identifier,state,customerprofileids 123-456-789AT,active,Alexa001;UserA ``` 
     * Import loyalty cards
     */
    async importLoyaltyCards(requestParameters: ImportLoyaltyCardsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Import> {
        const response = await this.importLoyaltyCardsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a CSV file containing existing customers to be assigned to existing tiers. Send the file as multipart data.  **Important:** This endpoint only works with loyalty programs with advanced tiers (with expiration and downgrade policy) feature enabled.  The CSV file should contain the following columns: - `subledgerid` (optional): The ID of the subledger. If this field is empty, the main ledger will be used. - `customerprofileid`: The integration ID of the customer profile to whom the tier should be assigned. - `tiername`: The name of an existing tier to assign to the customer. - `expirydate`: The expiration date of the tier when the tier is reevaluated. It should be a future date.  About customer assignment to a tier: - If the customer isn\'t already in a tier, the customer is assigned to the specified tier during the tier import. - If the customer is already in the tier that\'s specified in the CSV file, only the expiration date is updated.  **Note:** We recommend not using this endpoint to update the tier of a customer. To update a customer\'s tier, you can [add](/management-api#tag/Loyalty/operation/addLoyaltyPoints) or [deduct](/management-api#tag/Loyalty/operation/removeLoyaltyPoints) their loyalty points.  You can use the time zone of your choice. It is converted to UTC internally by Talon.One.  **Note:** We recommend limiting your file size to 500MB.  **Example:** ```csv subledgerid,customerprofileid,tiername,expirydate SUB1,alexa,Gold,2024-03-21T07:32:14Z ,george,Silver,2025-04-16T21:12:37Z SUB2,avocado,Bronze,2026-05-03T11:47:01Z ``` 
     * Import customers into loyalty tiers
     */
    async importLoyaltyCustomersTiersRaw(requestParameters: ImportLoyaltyCustomersTiersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Import>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling importLoyaltyCustomersTiers().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['upFile'] != null) {
            formParams.append('upFile', requestParameters['upFile'] as any);
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/import_customers_tiers`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportFromJSON(jsonValue));
    }

    /**
     * Upload a CSV file containing existing customers to be assigned to existing tiers. Send the file as multipart data.  **Important:** This endpoint only works with loyalty programs with advanced tiers (with expiration and downgrade policy) feature enabled.  The CSV file should contain the following columns: - `subledgerid` (optional): The ID of the subledger. If this field is empty, the main ledger will be used. - `customerprofileid`: The integration ID of the customer profile to whom the tier should be assigned. - `tiername`: The name of an existing tier to assign to the customer. - `expirydate`: The expiration date of the tier when the tier is reevaluated. It should be a future date.  About customer assignment to a tier: - If the customer isn\'t already in a tier, the customer is assigned to the specified tier during the tier import. - If the customer is already in the tier that\'s specified in the CSV file, only the expiration date is updated.  **Note:** We recommend not using this endpoint to update the tier of a customer. To update a customer\'s tier, you can [add](/management-api#tag/Loyalty/operation/addLoyaltyPoints) or [deduct](/management-api#tag/Loyalty/operation/removeLoyaltyPoints) their loyalty points.  You can use the time zone of your choice. It is converted to UTC internally by Talon.One.  **Note:** We recommend limiting your file size to 500MB.  **Example:** ```csv subledgerid,customerprofileid,tiername,expirydate SUB1,alexa,Gold,2024-03-21T07:32:14Z ,george,Silver,2025-04-16T21:12:37Z SUB2,avocado,Bronze,2026-05-03T11:47:01Z ``` 
     * Import customers into loyalty tiers
     */
    async importLoyaltyCustomersTiers(requestParameters: ImportLoyaltyCustomersTiersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Import> {
        const response = await this.importLoyaltyCustomersTiersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a CSV file containing the loyalty points you want to import into a given loyalty program. Send the file as multipart data.  Depending on the type of loyalty program, you can import points into a given customer profile or loyalty card.  The CSV file contains the following columns:  - `customerprofileid` (optional): For profile-based loyalty programs, the integration ID of the customer profile where the loyalty points are imported.    **Note**: If the customer profile does not exist, it will be created. The profile will not be visible in any Application   until a session or profile update is received for that profile. - `identifier` (optional): For card-based loyalty programs, the identifier of the loyalty card where the loyalty points are imported. - `amount`: The amount of points to award to the customer profile. - `startdate` (optional): The earliest date when the points can be redeemed. The points are `active` from this date until the expiration date.    This parameter accepts one of the following values:   - A timestamp string in RFC3339 format.   - `immediate`   - `on_action`      **Note**:   Empty or missing values default to `immediate`. - `expirydate` (optional): The latest date when the points can be redeemed. The points are `expired` after this date.    **Note**: It must be an RFC3339 timestamp string or string `unlimited`. Empty or missing values are considered `unlimited`.      If passed, `validityDuration` should be omitted. - `validityDuration` (optional): The duration for which the points remain active, relative to the    activation date.    The time format is an **integer** followed by one letter indicating the time unit.     Examples: `30s`, `40m`, `1h`, `5D`, `7W`, `10M`, `15Y`.     Available units:     - `s`: seconds   - `m`: minutes   - `h`: hours   - `D`: days   - `W`: weeks   - `M`: months   - `Y`: years     You can round certain units up or down:    - `_D` for rounding down days only. Signifies the start of the day.   - `_U` for rounding up days, weeks, months and years. Signifies the end of   the day, week, month or year.    If passed, `expirydate` should be omitted. - `subledgerid` (optional): The ID of the subledger that should received the points. - `reason` (optional): The reason why these points are awarded.  You can use the time zone of your choice. It is converted to UTC internally by Talon.One.  **Note:** For existing customer profiles and loyalty cards, the imported points are added to any previous active or pending points, depending on the value provided for `startdate`. If `startdate` matches the current date, the imported points are _active_. If it is later, the points are _pending_ until the date provided for `startdate` is reached.  **Note:** We recommend limiting your file size to 500MB.  **Example for profile-based programs:**  ```text customerprofileid,amount,startdate,expirydate,subledgerid,reason URNGV8294NV,100,2009-11-10T23:00:00Z,2009-11-11T23:00:00Z,subledger1,appeasement ```  **Example for card-based programs:**  ```text identifier,amount,startdate,expirydate,subledgerid,reason summer-loyalty-card-0543,100,2009-11-10T23:00:00Z,2009-11-11T23:00:00Z,subledger1,appeasement ``` 
     * Import loyalty points
     */
    async importLoyaltyPointsRaw(requestParameters: ImportLoyaltyPointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Import>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling importLoyaltyPoints().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['notificationsEnabled'] != null) {
            queryParameters['notificationsEnabled'] = requestParameters['notificationsEnabled'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['upFile'] != null) {
            formParams.append('upFile', requestParameters['upFile'] as any);
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/import_points`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportFromJSON(jsonValue));
    }

    /**
     * Upload a CSV file containing the loyalty points you want to import into a given loyalty program. Send the file as multipart data.  Depending on the type of loyalty program, you can import points into a given customer profile or loyalty card.  The CSV file contains the following columns:  - `customerprofileid` (optional): For profile-based loyalty programs, the integration ID of the customer profile where the loyalty points are imported.    **Note**: If the customer profile does not exist, it will be created. The profile will not be visible in any Application   until a session or profile update is received for that profile. - `identifier` (optional): For card-based loyalty programs, the identifier of the loyalty card where the loyalty points are imported. - `amount`: The amount of points to award to the customer profile. - `startdate` (optional): The earliest date when the points can be redeemed. The points are `active` from this date until the expiration date.    This parameter accepts one of the following values:   - A timestamp string in RFC3339 format.   - `immediate`   - `on_action`      **Note**:   Empty or missing values default to `immediate`. - `expirydate` (optional): The latest date when the points can be redeemed. The points are `expired` after this date.    **Note**: It must be an RFC3339 timestamp string or string `unlimited`. Empty or missing values are considered `unlimited`.      If passed, `validityDuration` should be omitted. - `validityDuration` (optional): The duration for which the points remain active, relative to the    activation date.    The time format is an **integer** followed by one letter indicating the time unit.     Examples: `30s`, `40m`, `1h`, `5D`, `7W`, `10M`, `15Y`.     Available units:     - `s`: seconds   - `m`: minutes   - `h`: hours   - `D`: days   - `W`: weeks   - `M`: months   - `Y`: years     You can round certain units up or down:    - `_D` for rounding down days only. Signifies the start of the day.   - `_U` for rounding up days, weeks, months and years. Signifies the end of   the day, week, month or year.    If passed, `expirydate` should be omitted. - `subledgerid` (optional): The ID of the subledger that should received the points. - `reason` (optional): The reason why these points are awarded.  You can use the time zone of your choice. It is converted to UTC internally by Talon.One.  **Note:** For existing customer profiles and loyalty cards, the imported points are added to any previous active or pending points, depending on the value provided for `startdate`. If `startdate` matches the current date, the imported points are _active_. If it is later, the points are _pending_ until the date provided for `startdate` is reached.  **Note:** We recommend limiting your file size to 500MB.  **Example for profile-based programs:**  ```text customerprofileid,amount,startdate,expirydate,subledgerid,reason URNGV8294NV,100,2009-11-10T23:00:00Z,2009-11-11T23:00:00Z,subledger1,appeasement ```  **Example for card-based programs:**  ```text identifier,amount,startdate,expirydate,subledgerid,reason summer-loyalty-card-0543,100,2009-11-10T23:00:00Z,2009-11-11T23:00:00Z,subledger1,appeasement ``` 
     * Import loyalty points
     */
    async importLoyaltyPoints(requestParameters: ImportLoyaltyPointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Import> {
        const response = await this.importLoyaltyPointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a CSV file containing the giveaway codes that should be created. Send the file as multipart data.  The CSV file contains the following columns: - `code` (required): The code of your giveaway, for instance, a gift card redemption code. - `startdate`:  The start date in RFC3339 of the code redemption period. - `enddate`: The last date in RFC3339 of the code redemption period. - `attributes`: A JSON object describing _custom_ giveaway attribute names and their values, enclosed with double quotation marks.    For example, if you created a [custom attribute](https://docs.talon.one/docs/dev/concepts/attributes#custom-attributes)   called `provider` associated with the giveaway entity, the object in the CSV file, when opened in a text editor, must be: `\"{\"provider\": \"myPartnerCompany\"}\"`.  The `startdate` and `enddate` have nothing to do with the _validity_ of the codes. They are only used by the Rule Engine to award the codes or not. You can use the time zone setting of your choice. The values are converted to UTC internally by Talon.One.  **Note:**  - We recommend limiting your file size to 500MB. - You can import the same code multiple times. Duplicate codes are treated and distributed to customers as unique codes.  **Example:**  ```text code,startdate,enddate,attributes GIVEAWAY1,2020-11-10T23:00:00Z,2022-11-11T23:00:00Z,\"{\"\"provider\"\": \"\"Amazon\"\"}\" GIVEAWAY2,2020-11-10T23:00:00Z,2022-11-11T23:00:00Z,\"{\"\"provider\"\": \"\"Amazon\"\"}\" GIVEAWAY3,2021-01-10T23:00:00Z,2022-11-11T23:00:00Z,\"{\"\"provider\"\": \"\"Aliexpress\"\"}\" ``` 
     * Import giveaway codes into a giveaway pool
     */
    async importPoolGiveawaysRaw(requestParameters: ImportPoolGiveawaysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Import>> {
        if (requestParameters['poolId'] == null) {
            throw new runtime.RequiredError(
                'poolId',
                'Required parameter "poolId" was null or undefined when calling importPoolGiveaways().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['upFile'] != null) {
            formParams.append('upFile', requestParameters['upFile'] as any);
        }


        let urlPath = `/v1/giveaways/pools/{poolId}/import`;
        urlPath = urlPath.replace(`{${"poolId"}}`, encodeURIComponent(String(requestParameters['poolId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportFromJSON(jsonValue));
    }

    /**
     * Upload a CSV file containing the giveaway codes that should be created. Send the file as multipart data.  The CSV file contains the following columns: - `code` (required): The code of your giveaway, for instance, a gift card redemption code. - `startdate`:  The start date in RFC3339 of the code redemption period. - `enddate`: The last date in RFC3339 of the code redemption period. - `attributes`: A JSON object describing _custom_ giveaway attribute names and their values, enclosed with double quotation marks.    For example, if you created a [custom attribute](https://docs.talon.one/docs/dev/concepts/attributes#custom-attributes)   called `provider` associated with the giveaway entity, the object in the CSV file, when opened in a text editor, must be: `\"{\"provider\": \"myPartnerCompany\"}\"`.  The `startdate` and `enddate` have nothing to do with the _validity_ of the codes. They are only used by the Rule Engine to award the codes or not. You can use the time zone setting of your choice. The values are converted to UTC internally by Talon.One.  **Note:**  - We recommend limiting your file size to 500MB. - You can import the same code multiple times. Duplicate codes are treated and distributed to customers as unique codes.  **Example:**  ```text code,startdate,enddate,attributes GIVEAWAY1,2020-11-10T23:00:00Z,2022-11-11T23:00:00Z,\"{\"\"provider\"\": \"\"Amazon\"\"}\" GIVEAWAY2,2020-11-10T23:00:00Z,2022-11-11T23:00:00Z,\"{\"\"provider\"\": \"\"Amazon\"\"}\" GIVEAWAY3,2021-01-10T23:00:00Z,2022-11-11T23:00:00Z,\"{\"\"provider\"\": \"\"Aliexpress\"\"}\" ``` 
     * Import giveaway codes into a giveaway pool
     */
    async importPoolGiveaways(requestParameters: ImportPoolGiveawaysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Import> {
        const response = await this.importPoolGiveawaysRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a CSV file containing the referrals that should be created. The file should be sent as multipart data.  The CSV file contains the following columns:  - `code` (required): The referral code. - `advocateprofileintegrationid` (required): The profile ID of the advocate. - `startdate`: The start date in RFC3339 of the code redemption period. - `expirydate`: The end date in RFC3339 of the code redemption period. - `limitval`: The maximum number of redemptions of this code. Defaults to `1` when left blank. - `attributes`: A JSON object describing _custom_ referral attribute names and their values, enclosed with double quotation marks.    For example, if you created a [custom attribute](https://docs.talon.one/docs/dev/concepts/attributes#custom-attributes)   called `category` associated with the referral entity, the object in the CSV file, when opened in a text editor, must be: `\"{\"category\": \"10_off\"}\"`.  You can use the time zone of your choice. It is converted to UTC internally by Talon.One.  **Important:** When you import a CSV file with referrals, a [customer profile](https://docs.talon.one/docs/dev/concepts/entities/customer-profiles) is **not** automatically created for each `advocateprofileintegrationid` column value. Use the [Update customer profile](https://docs.talon.one/integration-api#tag/Customer-profiles/operation/updateCustomerProfileV2) endpoint or the [Update multiple customer profiles](https://docs.talon.one/integration-api#tag/Customer-profiles/operation/updateCustomerProfilesV2) endpoint to create the customer profiles.  **Note:** We recommend limiting your file size to 500MB.  **Example:**  ```text code,startdate,expirydate,advocateprofileintegrationid,limitval,attributes REFERRAL_CODE1,2020-11-10T23:00:00Z,2021-11-11T23:00:00Z,integid_4,1,\"{\"\"my_attribute\"\": \"\"10_off\"\"}\" REFERRAL_CODE2,2020-11-10T23:00:00Z,2021-11-11T23:00:00Z,integid1,1,\"{\"\"my_attribute\"\": \"\"20_off\"\"}\" ``` 
     * Import referrals
     */
    async importReferralsRaw(requestParameters: ImportReferralsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Import>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling importReferrals().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling importReferrals().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['upFile'] != null) {
            formParams.append('upFile', requestParameters['upFile'] as any);
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/import_referrals`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportFromJSON(jsonValue));
    }

    /**
     * Upload a CSV file containing the referrals that should be created. The file should be sent as multipart data.  The CSV file contains the following columns:  - `code` (required): The referral code. - `advocateprofileintegrationid` (required): The profile ID of the advocate. - `startdate`: The start date in RFC3339 of the code redemption period. - `expirydate`: The end date in RFC3339 of the code redemption period. - `limitval`: The maximum number of redemptions of this code. Defaults to `1` when left blank. - `attributes`: A JSON object describing _custom_ referral attribute names and their values, enclosed with double quotation marks.    For example, if you created a [custom attribute](https://docs.talon.one/docs/dev/concepts/attributes#custom-attributes)   called `category` associated with the referral entity, the object in the CSV file, when opened in a text editor, must be: `\"{\"category\": \"10_off\"}\"`.  You can use the time zone of your choice. It is converted to UTC internally by Talon.One.  **Important:** When you import a CSV file with referrals, a [customer profile](https://docs.talon.one/docs/dev/concepts/entities/customer-profiles) is **not** automatically created for each `advocateprofileintegrationid` column value. Use the [Update customer profile](https://docs.talon.one/integration-api#tag/Customer-profiles/operation/updateCustomerProfileV2) endpoint or the [Update multiple customer profiles](https://docs.talon.one/integration-api#tag/Customer-profiles/operation/updateCustomerProfilesV2) endpoint to create the customer profiles.  **Note:** We recommend limiting your file size to 500MB.  **Example:**  ```text code,startdate,expirydate,advocateprofileintegrationid,limitval,attributes REFERRAL_CODE1,2020-11-10T23:00:00Z,2021-11-11T23:00:00Z,integid_4,1,\"{\"\"my_attribute\"\": \"\"10_off\"\"}\" REFERRAL_CODE2,2020-11-10T23:00:00Z,2021-11-11T23:00:00Z,integid1,1,\"{\"\"my_attribute\"\": \"\"20_off\"\"}\" ``` 
     * Import referrals
     */
    async importReferrals(requestParameters: ImportReferralsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Import> {
        const response = await this.importReferralsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * [Invite a user](https://docs.talon.one/docs/product/account/account-settings/managing-users#inviting-a-user) from an external identity provider to Talon.One by sending an invitation to their email address. 
     * Invite user from identity provider
     */
    async inviteUserExternalRaw(requestParameters: InviteUserExternalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['newExternalInvitation'] == null) {
            throw new runtime.RequiredError(
                'newExternalInvitation',
                'Required parameter "newExternalInvitation" was null or undefined when calling inviteUserExternal().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/users/invite`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewExternalInvitationToJSON(requestParameters['newExternalInvitation']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * [Invite a user](https://docs.talon.one/docs/product/account/account-settings/managing-users#inviting-a-user) from an external identity provider to Talon.One by sending an invitation to their email address. 
     * Invite user from identity provider
     */
    async inviteUserExternal(requestParameters: InviteUserExternalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.inviteUserExternalRaw(requestParameters, initOverrides);
    }

    /**
     * List account-level collections in the account.
     * List collections in account
     */
    async listAccountCollectionsRaw(requestParameters: ListAccountCollectionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListAccountCollections200Response>> {
        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['withTotalResultSize'] != null) {
            queryParameters['withTotalResultSize'] = requestParameters['withTotalResultSize'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/collections`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListAccountCollections200ResponseFromJSON(jsonValue));
    }

    /**
     * List account-level collections in the account.
     * List collections in account
     */
    async listAccountCollections(requestParameters: ListAccountCollectionsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListAccountCollections200Response> {
        const response = await this.listAccountCollectionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all the achievements for a specific campaign.
     * List achievements
     */
    async listAchievementsRaw(requestParameters: ListAchievementsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListAchievements200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling listAchievements().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling listAchievements().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['title'] != null) {
            queryParameters['title'] = requestParameters['title'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/achievements`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListAchievements200ResponseFromJSON(jsonValue));
    }

    /**
     * List all the achievements for a specific campaign.
     * List achievements
     */
    async listAchievements(requestParameters: ListAchievementsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListAchievements200Response> {
        const response = await this.listAchievementsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all roles.
     * List roles
     */
    async listAllRolesV2Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListAllRolesV2200Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v2/roles`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListAllRolesV2200ResponseFromJSON(jsonValue));
    }

    /**
     * List all roles.
     * List roles
     */
    async listAllRolesV2(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListAllRolesV2200Response> {
        const response = await this.listAllRolesV2Raw(initOverrides);
        return await response.value();
    }

    /**
     * Return the store budget limits for a given campaign.
     * List campaign store budget limits
     */
    async listCampaignStoreBudgetLimitsRaw(requestParameters: ListCampaignStoreBudgetLimitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListCampaignStoreBudgetLimits200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling listCampaignStoreBudgetLimits().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling listCampaignStoreBudgetLimits().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['action'] != null) {
            queryParameters['action'] = requestParameters['action'];
        }

        if (requestParameters['period'] != null) {
            queryParameters['period'] = requestParameters['period'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/stores/budgets`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListCampaignStoreBudgetLimits200ResponseFromJSON(jsonValue));
    }

    /**
     * Return the store budget limits for a given campaign.
     * List campaign store budget limits
     */
    async listCampaignStoreBudgetLimits(requestParameters: ListCampaignStoreBudgetLimitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListCampaignStoreBudgetLimits200Response> {
        const response = await this.listCampaignStoreBudgetLimitsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a paginated list of cart items in the given catalog. 
     * List items in a catalog
     */
    async listCatalogItemsRaw(requestParameters: ListCatalogItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListCatalogItems200Response>> {
        if (requestParameters['catalogId'] == null) {
            throw new runtime.RequiredError(
                'catalogId',
                'Required parameter "catalogId" was null or undefined when calling listCatalogItems().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['withTotalResultSize'] != null) {
            queryParameters['withTotalResultSize'] = requestParameters['withTotalResultSize'];
        }

        if (requestParameters['sku'] != null) {
            queryParameters['sku'] = requestParameters['sku'];
        }

        if (requestParameters['productNames'] != null) {
            queryParameters['productNames'] = requestParameters['productNames'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/catalogs/{catalogId}/items`;
        urlPath = urlPath.replace(`{${"catalogId"}}`, encodeURIComponent(String(requestParameters['catalogId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListCatalogItems200ResponseFromJSON(jsonValue));
    }

    /**
     * Return a paginated list of cart items in the given catalog. 
     * List items in a catalog
     */
    async listCatalogItems(requestParameters: ListCatalogItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListCatalogItems200Response> {
        const response = await this.listCatalogItemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List collections in a given campaign.
     * List collections in campaign
     */
    async listCollectionsRaw(requestParameters: ListCollectionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListAccountCollections200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling listCollections().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling listCollections().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['withTotalResultSize'] != null) {
            queryParameters['withTotalResultSize'] = requestParameters['withTotalResultSize'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/collections`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListAccountCollections200ResponseFromJSON(jsonValue));
    }

    /**
     * List collections in a given campaign.
     * List collections in campaign
     */
    async listCollections(requestParameters: ListCollectionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListAccountCollections200Response> {
        const response = await this.listCollectionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List campaign-level collections from all campaigns in a given Application.
     * List collections in Application
     */
    async listCollectionsInApplicationRaw(requestParameters: ListCollectionsInApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListAccountCollections200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling listCollectionsInApplication().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['withTotalResultSize'] != null) {
            queryParameters['withTotalResultSize'] = requestParameters['withTotalResultSize'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/collections`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListAccountCollections200ResponseFromJSON(jsonValue));
    }

    /**
     * List campaign-level collections from all campaigns in a given Application.
     * List collections in Application
     */
    async listCollectionsInApplication(requestParameters: ListCollectionsInApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListAccountCollections200Response> {
        const response = await this.listCollectionsInApplicationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all stores for a specific Application.
     * List stores
     */
    async listStoresRaw(requestParameters: ListStoresRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListStores200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling listStores().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['withTotalResultSize'] != null) {
            queryParameters['withTotalResultSize'] = requestParameters['withTotalResultSize'];
        }

        if (requestParameters['campaignId'] != null) {
            queryParameters['campaignId'] = requestParameters['campaignId'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['integrationId'] != null) {
            queryParameters['integrationId'] = requestParameters['integrationId'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/stores`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListStores200ResponseFromJSON(jsonValue));
    }

    /**
     * List all stores for a specific Application.
     * List stores
     */
    async listStores(requestParameters: ListStoresRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListStores200Response> {
        const response = await this.listStoresRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Validate the ownership of the API through a challenge-response mechanism.  This challenger endpoint is used by Okta to confirm that communication between Talon.One and Okta is correctly configured and accessible for provisioning and deprovisioning of Talon.One users, and that only Talon.One can receive and respond to events from Okta. 
     * Validate Okta API ownership
     */
    async oktaEventHandlerChallengeRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/provisioning/okta`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Validate the ownership of the API through a challenge-response mechanism.  This challenger endpoint is used by Okta to confirm that communication between Talon.One and Okta is correctly configured and accessible for provisioning and deprovisioning of Talon.One users, and that only Talon.One can receive and respond to events from Okta. 
     * Validate Okta API ownership
     */
    async oktaEventHandlerChallenge(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.oktaEventHandlerChallengeRaw(initOverrides);
    }

    /**
     * Deduct points from the specified loyalty program and specified customer profile.  **Important:** - Only active points can be deducted. - Only pending points are rolled back when a session is cancelled or reopened.  To get the `integrationId` of the profile from a `sessionId`, use the [Update customer session](https://docs.talon.one/integration-api#operation/updateCustomerSessionV2) endpoint. 
     * Deduct points from customer profile
     */
    async removeLoyaltyPointsRaw(requestParameters: RemoveLoyaltyPointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling removeLoyaltyPoints().'
            );
        }

        if (requestParameters['integrationId'] == null) {
            throw new runtime.RequiredError(
                'integrationId',
                'Required parameter "integrationId" was null or undefined when calling removeLoyaltyPoints().'
            );
        }

        if (requestParameters['deductLoyaltyPoints'] == null) {
            throw new runtime.RequiredError(
                'deductLoyaltyPoints',
                'Required parameter "deductLoyaltyPoints" was null or undefined when calling removeLoyaltyPoints().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/profile/{integrationId}/deduct_points`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));
        urlPath = urlPath.replace(`{${"integrationId"}}`, encodeURIComponent(String(requestParameters['integrationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DeductLoyaltyPointsToJSON(requestParameters['deductLoyaltyPoints']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deduct points from the specified loyalty program and specified customer profile.  **Important:** - Only active points can be deducted. - Only pending points are rolled back when a session is cancelled or reopened.  To get the `integrationId` of the profile from a `sessionId`, use the [Update customer session](https://docs.talon.one/integration-api#operation/updateCustomerSessionV2) endpoint. 
     * Deduct points from customer profile
     */
    async removeLoyaltyPoints(requestParameters: RemoveLoyaltyPointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeLoyaltyPointsRaw(requestParameters, initOverrides);
    }

    /**
     * Consumes the supplied password reset token and updates the password for the associated account. 
     * Reset password
     */
    async resetPasswordRaw(requestParameters: ResetPasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NewPassword>> {
        if (requestParameters['newPassword'] == null) {
            throw new runtime.RequiredError(
                'newPassword',
                'Required parameter "newPassword" was null or undefined when calling resetPassword().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/reset_password`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewPasswordToJSON(requestParameters['newPassword']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NewPasswordFromJSON(jsonValue));
    }

    /**
     * Consumes the supplied password reset token and updates the password for the associated account. 
     * Reset password
     */
    async resetPassword(requestParameters: ResetPasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NewPassword> {
        const response = await this.resetPasswordRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new Talon.One group using the SCIM Group provisioning protocol with an identity provider, for example, Microsoft Entra ID, and assign members from the payload to the new group. In Talon.One, a `Group` corresponds to a [role](https://docs.talon.one/docs/product/account/account-settings/managing-roles), and `members` are the [users](https://docs.talon.one/docs/product/account/account-settings/managing-users) assigned to that role.
     * Create SCIM group
     */
    async scimCreateGroupRaw(requestParameters: ScimCreateGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScimGroup>> {
        if (requestParameters['scimBaseGroup'] == null) {
            throw new runtime.RequiredError(
                'scimBaseGroup',
                'Required parameter "scimBaseGroup" was null or undefined when calling scimCreateGroup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/provisioning/scim/Groups`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ScimBaseGroupToJSON(requestParameters['scimBaseGroup']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScimGroupFromJSON(jsonValue));
    }

    /**
     * Create a new Talon.One group using the SCIM Group provisioning protocol with an identity provider, for example, Microsoft Entra ID, and assign members from the payload to the new group. In Talon.One, a `Group` corresponds to a [role](https://docs.talon.one/docs/product/account/account-settings/managing-roles), and `members` are the [users](https://docs.talon.one/docs/product/account/account-settings/managing-users) assigned to that role.
     * Create SCIM group
     */
    async scimCreateGroup(requestParameters: ScimCreateGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScimGroup> {
        const response = await this.scimCreateGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new Talon.One user using the SCIM provisioning protocol with an identity provider, for example, Microsoft Entra ID.
     * Create SCIM user
     */
    async scimCreateUserRaw(requestParameters: ScimCreateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScimUser>> {
        if (requestParameters['scimNewUser'] == null) {
            throw new runtime.RequiredError(
                'scimNewUser',
                'Required parameter "scimNewUser" was null or undefined when calling scimCreateUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/provisioning/scim/Users`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ScimNewUserToJSON(requestParameters['scimNewUser']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScimUserFromJSON(jsonValue));
    }

    /**
     * Create a new Talon.One user using the SCIM provisioning protocol with an identity provider, for example, Microsoft Entra ID.
     * Create SCIM user
     */
    async scimCreateUser(requestParameters: ScimCreateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScimUser> {
        const response = await this.scimCreateUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a specific group created using the SCIM provisioning protocol with an identity provider, for example, Microsoft Entra ID. In Talon.One, a `Group` corresponds to a [role](https://docs.talon.one/docs/product/account/account-settings/managing-roles), and `members` are the [users](https://docs.talon.one/docs/product/account/account-settings/managing-users) assigned to that role.
     * Delete SCIM group
     */
    async scimDeleteGroupRaw(requestParameters: ScimDeleteGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['groupId'] == null) {
            throw new runtime.RequiredError(
                'groupId',
                'Required parameter "groupId" was null or undefined when calling scimDeleteGroup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/provisioning/scim/Groups/{groupId}`;
        urlPath = urlPath.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters['groupId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a specific group created using the SCIM provisioning protocol with an identity provider, for example, Microsoft Entra ID. In Talon.One, a `Group` corresponds to a [role](https://docs.talon.one/docs/product/account/account-settings/managing-roles), and `members` are the [users](https://docs.talon.one/docs/product/account/account-settings/managing-users) assigned to that role.
     * Delete SCIM group
     */
    async scimDeleteGroup(requestParameters: ScimDeleteGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.scimDeleteGroupRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a specific Talon.One user created using the SCIM provisioning protocol with an identity provider, for example, Microsoft Entra ID.
     * Delete SCIM user
     */
    async scimDeleteUserRaw(requestParameters: ScimDeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling scimDeleteUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/provisioning/scim/Users/{userId}`;
        urlPath = urlPath.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a specific Talon.One user created using the SCIM provisioning protocol with an identity provider, for example, Microsoft Entra ID.
     * Delete SCIM user
     */
    async scimDeleteUser(requestParameters: ScimDeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.scimDeleteUserRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve data for a specific group created using the SCIM provisioning protocol with an identity provider, for example, Microsoft Entra ID. In Talon.One, a `Group` corresponds to a [role](https://docs.talon.one/docs/product/account/account-settings/managing-roles), and `members` are the [users](https://docs.talon.one/docs/product/account/account-settings/managing-users) assigned to that role.
     * Get SCIM group
     */
    async scimGetGroupRaw(requestParameters: ScimGetGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScimGroup>> {
        if (requestParameters['groupId'] == null) {
            throw new runtime.RequiredError(
                'groupId',
                'Required parameter "groupId" was null or undefined when calling scimGetGroup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/provisioning/scim/Groups/{groupId}`;
        urlPath = urlPath.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters['groupId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScimGroupFromJSON(jsonValue));
    }

    /**
     * Retrieve data for a specific group created using the SCIM provisioning protocol with an identity provider, for example, Microsoft Entra ID. In Talon.One, a `Group` corresponds to a [role](https://docs.talon.one/docs/product/account/account-settings/managing-roles), and `members` are the [users](https://docs.talon.one/docs/product/account/account-settings/managing-users) assigned to that role.
     * Get SCIM group
     */
    async scimGetGroup(requestParameters: ScimGetGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScimGroup> {
        const response = await this.scimGetGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a paginated list of groups created using the SCIM protocol with an identity provider, for example, Microsoft Entra ID. In Talon.One, a `Group` corresponds to a [role](https://docs.talon.one/docs/product/account/account-settings/managing-roles), and `members` are the [users](https://docs.talon.one/docs/product/account/account-settings/managing-users) assigned to that role.
     * List SCIM groups
     */
    async scimGetGroupsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScimGroupsListResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/provisioning/scim/Groups`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScimGroupsListResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a paginated list of groups created using the SCIM protocol with an identity provider, for example, Microsoft Entra ID. In Talon.One, a `Group` corresponds to a [role](https://docs.talon.one/docs/product/account/account-settings/managing-roles), and `members` are the [users](https://docs.talon.one/docs/product/account/account-settings/managing-users) assigned to that role.
     * List SCIM groups
     */
    async scimGetGroups(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScimGroupsListResponse> {
        const response = await this.scimGetGroupsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of resource types supported by the SCIM provisioning protocol.  Resource types define the various kinds of resources that can be managed via the SCIM API, such as users, groups, or custom-defined resources. 
     * List supported SCIM resource types
     */
    async scimGetResourceTypesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScimResourceTypesListResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/provisioning/scim/ResourceTypes`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScimResourceTypesListResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of resource types supported by the SCIM provisioning protocol.  Resource types define the various kinds of resources that can be managed via the SCIM API, such as users, groups, or custom-defined resources. 
     * List supported SCIM resource types
     */
    async scimGetResourceTypes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScimResourceTypesListResponse> {
        const response = await this.scimGetResourceTypesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of schemas supported by the SCIM provisioning protocol.  Schemas define the structure and attributes of the different resources that can be managed via the SCIM API, such as users, groups, and any custom-defined resources. 
     * List supported SCIM schemas
     */
    async scimGetSchemasRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScimSchemasListResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/provisioning/scim/Schemas`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScimSchemasListResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of schemas supported by the SCIM provisioning protocol.  Schemas define the structure and attributes of the different resources that can be managed via the SCIM API, such as users, groups, and any custom-defined resources. 
     * List supported SCIM schemas
     */
    async scimGetSchemas(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScimSchemasListResponse> {
        const response = await this.scimGetSchemasRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the configuration settings of the SCIM service provider. It provides details about the features and capabilities supported by the SCIM API, such as the different operation settings. 
     * Get SCIM service provider configuration
     */
    async scimGetServiceProviderConfigRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScimServiceProviderConfigResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/provisioning/scim/ServiceProviderConfig`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScimServiceProviderConfigResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the configuration settings of the SCIM service provider. It provides details about the features and capabilities supported by the SCIM API, such as the different operation settings. 
     * Get SCIM service provider configuration
     */
    async scimGetServiceProviderConfig(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScimServiceProviderConfigResponse> {
        const response = await this.scimGetServiceProviderConfigRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve data for a specific Talon.One user created using the SCIM provisioning protocol with an identity provider, for example, Microsoft Entra ID.
     * Get SCIM user
     */
    async scimGetUserRaw(requestParameters: ScimGetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScimUser>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling scimGetUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/provisioning/scim/Users/{userId}`;
        urlPath = urlPath.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScimUserFromJSON(jsonValue));
    }

    /**
     * Retrieve data for a specific Talon.One user created using the SCIM provisioning protocol with an identity provider, for example, Microsoft Entra ID.
     * Get SCIM user
     */
    async scimGetUser(requestParameters: ScimGetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScimUser> {
        const response = await this.scimGetUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a paginated list of users that have been provisioned using the SCIM protocol with an identity provider, for example, Microsoft Entra ID.
     * List SCIM users
     */
    async scimGetUsersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScimUsersListResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/provisioning/scim/Users`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScimUsersListResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a paginated list of users that have been provisioned using the SCIM protocol with an identity provider, for example, Microsoft Entra ID.
     * List SCIM users
     */
    async scimGetUsers(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScimUsersListResponse> {
        const response = await this.scimGetUsersRaw(initOverrides);
        return await response.value();
    }

    /**
     * Update certain attributes of a group created using the SCIM provisioning protocol with an identity provider, for example, Microsoft Entra ID. This endpoint allows for selective adding, removing, or replacing of specific group attributes while other attributes remain unchanged. In Talon.One, a `Group` corresponds to a [role](https://docs.talon.one/docs/product/account/account-settings/managing-roles), and `members` are the [users](https://docs.talon.one/docs/product/account/account-settings/managing-users) assigned to that role. 
     * Update SCIM group attributes
     */
    async scimPatchGroupRaw(requestParameters: ScimPatchGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScimGroup>> {
        if (requestParameters['groupId'] == null) {
            throw new runtime.RequiredError(
                'groupId',
                'Required parameter "groupId" was null or undefined when calling scimPatchGroup().'
            );
        }

        if (requestParameters['scimPatchRequest'] == null) {
            throw new runtime.RequiredError(
                'scimPatchRequest',
                'Required parameter "scimPatchRequest" was null or undefined when calling scimPatchGroup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/provisioning/scim/Groups/{groupId}`;
        urlPath = urlPath.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters['groupId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ScimPatchRequestToJSON(requestParameters['scimPatchRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScimGroupFromJSON(jsonValue));
    }

    /**
     * Update certain attributes of a group created using the SCIM provisioning protocol with an identity provider, for example, Microsoft Entra ID. This endpoint allows for selective adding, removing, or replacing of specific group attributes while other attributes remain unchanged. In Talon.One, a `Group` corresponds to a [role](https://docs.talon.one/docs/product/account/account-settings/managing-roles), and `members` are the [users](https://docs.talon.one/docs/product/account/account-settings/managing-users) assigned to that role. 
     * Update SCIM group attributes
     */
    async scimPatchGroup(requestParameters: ScimPatchGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScimGroup> {
        const response = await this.scimPatchGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update certain attributes of a specific Talon.One user created using the SCIM provisioning protocol with an identity provider, for example, Microsoft Entra ID.  This endpoint allows for selective adding, removing, or replacing specific attributes while leaving other attributes unchanged. 
     * Update SCIM user attributes
     */
    async scimPatchUserRaw(requestParameters: ScimPatchUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScimUser>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling scimPatchUser().'
            );
        }

        if (requestParameters['scimPatchRequest'] == null) {
            throw new runtime.RequiredError(
                'scimPatchRequest',
                'Required parameter "scimPatchRequest" was null or undefined when calling scimPatchUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/provisioning/scim/Users/{userId}`;
        urlPath = urlPath.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ScimPatchRequestToJSON(requestParameters['scimPatchRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScimUserFromJSON(jsonValue));
    }

    /**
     * Update certain attributes of a specific Talon.One user created using the SCIM provisioning protocol with an identity provider, for example, Microsoft Entra ID.  This endpoint allows for selective adding, removing, or replacing specific attributes while leaving other attributes unchanged. 
     * Update SCIM user attributes
     */
    async scimPatchUser(requestParameters: ScimPatchUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScimUser> {
        const response = await this.scimPatchUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the details of a specific group created using the SCIM provisioning protocol with an identity provider, for example, Microsoft Entra ID. This endpoint replaces all attributes of the given group with the attributes provided in the request payload. In Talon.One, a `Group` corresponds to a [role](https://docs.talon.one/docs/product/account/account-settings/managing-roles), and `members` are the [users](https://docs.talon.one/docs/product/account/account-settings/managing-users) assigned to that role. 
     * Update SCIM group
     */
    async scimReplaceGroupAttributesRaw(requestParameters: ScimReplaceGroupAttributesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScimGroup>> {
        if (requestParameters['groupId'] == null) {
            throw new runtime.RequiredError(
                'groupId',
                'Required parameter "groupId" was null or undefined when calling scimReplaceGroupAttributes().'
            );
        }

        if (requestParameters['scimBaseGroup'] == null) {
            throw new runtime.RequiredError(
                'scimBaseGroup',
                'Required parameter "scimBaseGroup" was null or undefined when calling scimReplaceGroupAttributes().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/provisioning/scim/Groups/{groupId}`;
        urlPath = urlPath.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters['groupId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ScimBaseGroupToJSON(requestParameters['scimBaseGroup']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScimGroupFromJSON(jsonValue));
    }

    /**
     * Update the details of a specific group created using the SCIM provisioning protocol with an identity provider, for example, Microsoft Entra ID. This endpoint replaces all attributes of the given group with the attributes provided in the request payload. In Talon.One, a `Group` corresponds to a [role](https://docs.talon.one/docs/product/account/account-settings/managing-roles), and `members` are the [users](https://docs.talon.one/docs/product/account/account-settings/managing-users) assigned to that role. 
     * Update SCIM group
     */
    async scimReplaceGroupAttributes(requestParameters: ScimReplaceGroupAttributesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScimGroup> {
        const response = await this.scimReplaceGroupAttributesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the details of a specific Talon.One user created using the SCIM provisioning protocol with an identity provider, for example, Microsoft Entra ID.  This endpoint replaces all attributes of the specific user with the attributes provided in the request payload. 
     * Update SCIM user
     */
    async scimReplaceUserAttributesRaw(requestParameters: ScimReplaceUserAttributesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScimUser>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling scimReplaceUserAttributes().'
            );
        }

        if (requestParameters['scimNewUser'] == null) {
            throw new runtime.RequiredError(
                'scimNewUser',
                'Required parameter "scimNewUser" was null or undefined when calling scimReplaceUserAttributes().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/provisioning/scim/Users/{userId}`;
        urlPath = urlPath.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ScimNewUserToJSON(requestParameters['scimNewUser']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScimUserFromJSON(jsonValue));
    }

    /**
     * Update the details of a specific Talon.One user created using the SCIM provisioning protocol with an identity provider, for example, Microsoft Entra ID.  This endpoint replaces all attributes of the specific user with the attributes provided in the request payload. 
     * Update SCIM user
     */
    async scimReplaceUserAttributes(requestParameters: ScimReplaceUserAttributesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScimUser> {
        const response = await this.scimReplaceUserAttributesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List the coupons whose attributes match the query criteria in all the campaigns of the given Application.  The match is successful if all the attributes of the request are found in a coupon, even if the coupon has more attributes that are not present on the request.  **Note:** The total count is not included in the response. 
     * List coupons that match the given attributes (without total count)
     */
    async searchCouponsAdvancedApplicationWideWithoutTotalCountRaw(requestParameters: SearchCouponsAdvancedApplicationWideWithoutTotalCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCouponsWithoutTotalCount200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling searchCouponsAdvancedApplicationWideWithoutTotalCount().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling searchCouponsAdvancedApplicationWideWithoutTotalCount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['value'] != null) {
            queryParameters['value'] = requestParameters['value'];
        }

        if (requestParameters['createdBefore'] != null) {
            queryParameters['createdBefore'] = (requestParameters['createdBefore'] as any).toISOString();
        }

        if (requestParameters['createdAfter'] != null) {
            queryParameters['createdAfter'] = (requestParameters['createdAfter'] as any).toISOString();
        }

        if (requestParameters['valid'] != null) {
            queryParameters['valid'] = requestParameters['valid'];
        }

        if (requestParameters['usable'] != null) {
            queryParameters['usable'] = requestParameters['usable'];
        }

        if (requestParameters['referralId'] != null) {
            queryParameters['referralId'] = requestParameters['referralId'];
        }

        if (requestParameters['recipientIntegrationId'] != null) {
            queryParameters['recipientIntegrationId'] = requestParameters['recipientIntegrationId'];
        }

        if (requestParameters['batchId'] != null) {
            queryParameters['batchId'] = requestParameters['batchId'];
        }

        if (requestParameters['exactMatch'] != null) {
            queryParameters['exactMatch'] = requestParameters['exactMatch'];
        }

        if (requestParameters['campaignState'] != null) {
            queryParameters['campaignState'] = requestParameters['campaignState'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/coupons_search_advanced/no_total`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetCouponsWithoutTotalCount200ResponseFromJSON(jsonValue));
    }

    /**
     * List the coupons whose attributes match the query criteria in all the campaigns of the given Application.  The match is successful if all the attributes of the request are found in a coupon, even if the coupon has more attributes that are not present on the request.  **Note:** The total count is not included in the response. 
     * List coupons that match the given attributes (without total count)
     */
    async searchCouponsAdvancedApplicationWideWithoutTotalCount(requestParameters: SearchCouponsAdvancedApplicationWideWithoutTotalCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCouponsWithoutTotalCount200Response> {
        const response = await this.searchCouponsAdvancedApplicationWideWithoutTotalCountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List the coupons whose attributes match the query criteria in the given campaign.  The match is successful if all the attributes of the request are found in a coupon, even if the coupon has more attributes that are not present on the request.  **Note:** The total count is not included in the response. 
     * List coupons that match the given attributes in campaign (without total count)
     */
    async searchCouponsAdvancedWithoutTotalCountRaw(requestParameters: SearchCouponsAdvancedWithoutTotalCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetCouponsWithoutTotalCount200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling searchCouponsAdvancedWithoutTotalCount().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling searchCouponsAdvancedWithoutTotalCount().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling searchCouponsAdvancedWithoutTotalCount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['value'] != null) {
            queryParameters['value'] = requestParameters['value'];
        }

        if (requestParameters['createdBefore'] != null) {
            queryParameters['createdBefore'] = (requestParameters['createdBefore'] as any).toISOString();
        }

        if (requestParameters['createdAfter'] != null) {
            queryParameters['createdAfter'] = (requestParameters['createdAfter'] as any).toISOString();
        }

        if (requestParameters['valid'] != null) {
            queryParameters['valid'] = requestParameters['valid'];
        }

        if (requestParameters['usable'] != null) {
            queryParameters['usable'] = requestParameters['usable'];
        }

        if (requestParameters['referralId'] != null) {
            queryParameters['referralId'] = requestParameters['referralId'];
        }

        if (requestParameters['recipientIntegrationId'] != null) {
            queryParameters['recipientIntegrationId'] = requestParameters['recipientIntegrationId'];
        }

        if (requestParameters['exactMatch'] != null) {
            queryParameters['exactMatch'] = requestParameters['exactMatch'];
        }

        if (requestParameters['batchId'] != null) {
            queryParameters['batchId'] = requestParameters['batchId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_search_advanced/no_total`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetCouponsWithoutTotalCount200ResponseFromJSON(jsonValue));
    }

    /**
     * List the coupons whose attributes match the query criteria in the given campaign.  The match is successful if all the attributes of the request are found in a coupon, even if the coupon has more attributes that are not present on the request.  **Note:** The total count is not included in the response. 
     * List coupons that match the given attributes in campaign (without total count)
     */
    async searchCouponsAdvancedWithoutTotalCount(requestParameters: SearchCouponsAdvancedWithoutTotalCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetCouponsWithoutTotalCount200Response> {
        const response = await this.searchCouponsAdvancedWithoutTotalCountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch a summary of all store budget information for a given campaign.
     * Get summary of campaign store budgets
     */
    async summarizeCampaignStoreBudgetRaw(requestParameters: SummarizeCampaignStoreBudgetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SummarizeCampaignStoreBudget200Response>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling summarizeCampaignStoreBudget().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling summarizeCampaignStoreBudget().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/stores/budgets/summary`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SummarizeCampaignStoreBudget200ResponseFromJSON(jsonValue));
    }

    /**
     * Fetch a summary of all store budget information for a given campaign.
     * Get summary of campaign store budgets
     */
    async summarizeCampaignStoreBudget(requestParameters: SummarizeCampaignStoreBudgetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SummarizeCampaignStoreBudget200Response> {
        const response = await this.summarizeCampaignStoreBudgetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Transfer loyalty card data, such as linked customers, loyalty balances and transactions, from a given loyalty card to a new, automatically created loyalty card.  **Important:**  - The original card is automatically blocked once the new card is created, and it cannot be activated again. - The default status of the new card is _active_. 
     * Transfer card data
     */
    async transferLoyaltyCardRaw(requestParameters: TransferLoyaltyCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling transferLoyaltyCard().'
            );
        }

        if (requestParameters['loyaltyCardId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyCardId',
                'Required parameter "loyaltyCardId" was null or undefined when calling transferLoyaltyCard().'
            );
        }

        if (requestParameters['transferLoyaltyCard'] == null) {
            throw new runtime.RequiredError(
                'transferLoyaltyCard',
                'Required parameter "transferLoyaltyCard" was null or undefined when calling transferLoyaltyCard().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/cards/{loyaltyCardId}/transfer`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));
        urlPath = urlPath.replace(`{${"loyaltyCardId"}}`, encodeURIComponent(String(requestParameters['loyaltyCardId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: TransferLoyaltyCardToJSON(requestParameters['transferLoyaltyCard']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Transfer loyalty card data, such as linked customers, loyalty balances and transactions, from a given loyalty card to a new, automatically created loyalty card.  **Important:**  - The original card is automatically blocked once the new card is created, and it cannot be activated again. - The default status of the new card is _active_. 
     * Transfer card data
     */
    async transferLoyaltyCard(requestParameters: TransferLoyaltyCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.transferLoyaltyCardRaw(requestParameters, initOverrides);
    }

    /**
     * Edit the description of a given account-level collection and enable or disable the collection in the specified Applications.
     * Update account-level collection
     */
    async updateAccountCollectionRaw(requestParameters: UpdateAccountCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Collection>> {
        if (requestParameters['collectionId'] == null) {
            throw new runtime.RequiredError(
                'collectionId',
                'Required parameter "collectionId" was null or undefined when calling updateAccountCollection().'
            );
        }

        if (requestParameters['updateCollection'] == null) {
            throw new runtime.RequiredError(
                'updateCollection',
                'Required parameter "updateCollection" was null or undefined when calling updateAccountCollection().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/collections/{collectionId}`;
        urlPath = urlPath.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters['collectionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCollectionToJSON(requestParameters['updateCollection']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CollectionFromJSON(jsonValue));
    }

    /**
     * Edit the description of a given account-level collection and enable or disable the collection in the specified Applications.
     * Update account-level collection
     */
    async updateAccountCollection(requestParameters: UpdateAccountCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Collection> {
        const response = await this.updateAccountCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the details of a specific achievement.
     * Update achievement
     */
    async updateAchievementRaw(requestParameters: UpdateAchievementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Achievement>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling updateAchievement().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling updateAchievement().'
            );
        }

        if (requestParameters['achievementId'] == null) {
            throw new runtime.RequiredError(
                'achievementId',
                'Required parameter "achievementId" was null or undefined when calling updateAchievement().'
            );
        }

        if (requestParameters['updateAchievement'] == null) {
            throw new runtime.RequiredError(
                'updateAchievement',
                'Required parameter "updateAchievement" was null or undefined when calling updateAchievement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/achievements/{achievementId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));
        urlPath = urlPath.replace(`{${"achievementId"}}`, encodeURIComponent(String(requestParameters['achievementId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateAchievementToJSON(requestParameters['updateAchievement']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AchievementFromJSON(jsonValue));
    }

    /**
     * Update the details of a specific achievement.
     * Update achievement
     */
    async updateAchievement(requestParameters: UpdateAchievementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Achievement> {
        const response = await this.updateAchievementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates an existing additional cost. Once created, the only property of an additional cost that cannot be changed is the `name` property (or **API name** in the Campaign Manager). This restriction is in place to prevent accidentally breaking live integrations. 
     * Update additional cost
     */
    async updateAdditionalCostRaw(requestParameters: UpdateAdditionalCostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountAdditionalCost>> {
        if (requestParameters['additionalCostId'] == null) {
            throw new runtime.RequiredError(
                'additionalCostId',
                'Required parameter "additionalCostId" was null or undefined when calling updateAdditionalCost().'
            );
        }

        if (requestParameters['newAdditionalCost'] == null) {
            throw new runtime.RequiredError(
                'newAdditionalCost',
                'Required parameter "newAdditionalCost" was null or undefined when calling updateAdditionalCost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/additional_costs/{additionalCostId}`;
        urlPath = urlPath.replace(`{${"additionalCostId"}}`, encodeURIComponent(String(requestParameters['additionalCostId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: NewAdditionalCostToJSON(requestParameters['newAdditionalCost']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountAdditionalCostFromJSON(jsonValue));
    }

    /**
     * Updates an existing additional cost. Once created, the only property of an additional cost that cannot be changed is the `name` property (or **API name** in the Campaign Manager). This restriction is in place to prevent accidentally breaking live integrations. 
     * Update additional cost
     */
    async updateAdditionalCost(requestParameters: UpdateAdditionalCostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountAdditionalCost> {
        const response = await this.updateAdditionalCostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an existing custom attribute. Once created, the only property of a custom attribute that can be changed is the description.  To change the `type` or `name` property of a custom attribute, create a new attribute and update any relevant integrations and rules to use the new attribute. 
     * Update custom attribute
     */
    async updateAttributeRaw(requestParameters: UpdateAttributeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Attribute>> {
        if (requestParameters['attributeId'] == null) {
            throw new runtime.RequiredError(
                'attributeId',
                'Required parameter "attributeId" was null or undefined when calling updateAttribute().'
            );
        }

        if (requestParameters['newAttribute'] == null) {
            throw new runtime.RequiredError(
                'newAttribute',
                'Required parameter "newAttribute" was null or undefined when calling updateAttribute().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/attributes/{attributeId}`;
        urlPath = urlPath.replace(`{${"attributeId"}}`, encodeURIComponent(String(requestParameters['attributeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: NewAttributeToJSON(requestParameters['newAttribute']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AttributeFromJSON(jsonValue));
    }

    /**
     * Update an existing custom attribute. Once created, the only property of a custom attribute that can be changed is the description.  To change the `type` or `name` property of a custom attribute, create a new attribute and update any relevant integrations and rules to use the new attribute. 
     * Update custom attribute
     */
    async updateAttribute(requestParameters: UpdateAttributeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Attribute> {
        const response = await this.updateAttributeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the given campaign.  **Important:** You cannot use this endpoint to update campaigns if [campaign staging and revisions](https://docs.talon.one/docs/product/applications/managing-general-settings#campaign-staging-and-revisions) is enabled for your Application. 
     * Update campaign
     */
    async updateCampaignRaw(requestParameters: UpdateCampaignRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Campaign>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling updateCampaign().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling updateCampaign().'
            );
        }

        if (requestParameters['updateCampaign'] == null) {
            throw new runtime.RequiredError(
                'updateCampaign',
                'Required parameter "updateCampaign" was null or undefined when calling updateCampaign().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCampaignToJSON(requestParameters['updateCampaign']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CampaignFromJSON(jsonValue));
    }

    /**
     * Update the given campaign.  **Important:** You cannot use this endpoint to update campaigns if [campaign staging and revisions](https://docs.talon.one/docs/product/applications/managing-general-settings#campaign-staging-and-revisions) is enabled for your Application. 
     * Update campaign
     */
    async updateCampaign(requestParameters: UpdateCampaignRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Campaign> {
        const response = await this.updateCampaignRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit the description of a given campaign-level collection.
     * Update campaign-level collection\'s description
     */
    async updateCollectionRaw(requestParameters: UpdateCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Collection>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling updateCollection().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling updateCollection().'
            );
        }

        if (requestParameters['collectionId'] == null) {
            throw new runtime.RequiredError(
                'collectionId',
                'Required parameter "collectionId" was null or undefined when calling updateCollection().'
            );
        }

        if (requestParameters['updateCampaignCollection'] == null) {
            throw new runtime.RequiredError(
                'updateCampaignCollection',
                'Required parameter "updateCampaignCollection" was null or undefined when calling updateCollection().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/collections/{collectionId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));
        urlPath = urlPath.replace(`{${"collectionId"}}`, encodeURIComponent(String(requestParameters['collectionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCampaignCollectionToJSON(requestParameters['updateCampaignCollection']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CollectionFromJSON(jsonValue));
    }

    /**
     * Edit the description of a given campaign-level collection.
     * Update campaign-level collection\'s description
     */
    async updateCollection(requestParameters: UpdateCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Collection> {
        const response = await this.updateCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the specified coupon.  <div class=\"redoc-section\">   <p class=\"title\">Important</p>    <p>With this <code>PUT</code> endpoint, if you do not explicitly set a value for the <code>startDate</code>, <code>expiryDate</code>, and <code>recipientIntegrationId</code> properties in your request, it is automatically set to <code>null</code>.</p>  </div> 
     * Update coupon
     */
    async updateCouponRaw(requestParameters: UpdateCouponRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Coupon>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling updateCoupon().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling updateCoupon().'
            );
        }

        if (requestParameters['couponId'] == null) {
            throw new runtime.RequiredError(
                'couponId',
                'Required parameter "couponId" was null or undefined when calling updateCoupon().'
            );
        }

        if (requestParameters['updateCoupon'] == null) {
            throw new runtime.RequiredError(
                'updateCoupon',
                'Required parameter "updateCoupon" was null or undefined when calling updateCoupon().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/coupons/{couponId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));
        urlPath = urlPath.replace(`{${"couponId"}}`, encodeURIComponent(String(requestParameters['couponId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCouponToJSON(requestParameters['updateCoupon']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CouponFromJSON(jsonValue));
    }

    /**
     * Update the specified coupon.  <div class=\"redoc-section\">   <p class=\"title\">Important</p>    <p>With this <code>PUT</code> endpoint, if you do not explicitly set a value for the <code>startDate</code>, <code>expiryDate</code>, and <code>recipientIntegrationId</code> properties in your request, it is automatically set to <code>null</code>.</p>  </div> 
     * Update coupon
     */
    async updateCoupon(requestParameters: UpdateCouponRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Coupon> {
        const response = await this.updateCouponRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update all coupons or a specific batch of coupons in the given campaign. You can find the `batchId` on the **Coupons** page of your campaign in the Campaign Manager, or you can use [List coupons](#operation/getCouponsWithoutTotalCount).  <div class=\"redoc-section\">   <p class=\"title\">Important</p>    <ul>     <li>Only send sequential requests to this endpoint.</li>     <li>Requests to this endpoint time out after 30 minutes. If you hit a timeout, contact our support team.</li>     <li>With this <code>PUT</code> endpoint, if you do not explicitly set a value for the <code>startDate</code> and <code>expiryDate</code> properties in your request, it is automatically set to <code>null</code>.</li>   </ul>  </div>  To update a specific coupon, use [Update coupon](#operation/updateCoupon). 
     * Update coupons
     */
    async updateCouponBatchRaw(requestParameters: UpdateCouponBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling updateCouponBatch().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling updateCouponBatch().'
            );
        }

        if (requestParameters['updateCouponBatch'] == null) {
            throw new runtime.RequiredError(
                'updateCouponBatch',
                'Required parameter "updateCouponBatch" was null or undefined when calling updateCouponBatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/coupons`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCouponBatchToJSON(requestParameters['updateCouponBatch']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update all coupons or a specific batch of coupons in the given campaign. You can find the `batchId` on the **Coupons** page of your campaign in the Campaign Manager, or you can use [List coupons](#operation/getCouponsWithoutTotalCount).  <div class=\"redoc-section\">   <p class=\"title\">Important</p>    <ul>     <li>Only send sequential requests to this endpoint.</li>     <li>Requests to this endpoint time out after 30 minutes. If you hit a timeout, contact our support team.</li>     <li>With this <code>PUT</code> endpoint, if you do not explicitly set a value for the <code>startDate</code> and <code>expiryDate</code> properties in your request, it is automatically set to <code>null</code>.</li>   </ul>  </div>  To update a specific coupon, use [Update coupon](#operation/updateCoupon). 
     * Update coupons
     */
    async updateCouponBatch(requestParameters: UpdateCouponBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateCouponBatchRaw(requestParameters, initOverrides);
    }

    /**
     * Update the status of the given loyalty card. A card can be _active_ or _inactive_.
     * Update loyalty card status
     */
    async updateLoyaltyCardRaw(requestParameters: UpdateLoyaltyCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoyaltyCard>> {
        if (requestParameters['loyaltyProgramId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyProgramId',
                'Required parameter "loyaltyProgramId" was null or undefined when calling updateLoyaltyCard().'
            );
        }

        if (requestParameters['loyaltyCardId'] == null) {
            throw new runtime.RequiredError(
                'loyaltyCardId',
                'Required parameter "loyaltyCardId" was null or undefined when calling updateLoyaltyCard().'
            );
        }

        if (requestParameters['updateLoyaltyCard'] == null) {
            throw new runtime.RequiredError(
                'updateLoyaltyCard',
                'Required parameter "updateLoyaltyCard" was null or undefined when calling updateLoyaltyCard().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/loyalty_programs/{loyaltyProgramId}/cards/{loyaltyCardId}`;
        urlPath = urlPath.replace(`{${"loyaltyProgramId"}}`, encodeURIComponent(String(requestParameters['loyaltyProgramId'])));
        urlPath = urlPath.replace(`{${"loyaltyCardId"}}`, encodeURIComponent(String(requestParameters['loyaltyCardId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateLoyaltyCardToJSON(requestParameters['updateLoyaltyCard']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LoyaltyCardFromJSON(jsonValue));
    }

    /**
     * Update the status of the given loyalty card. A card can be _active_ or _inactive_.
     * Update loyalty card status
     */
    async updateLoyaltyCard(requestParameters: UpdateLoyaltyCardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoyaltyCard> {
        const response = await this.updateLoyaltyCardRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the specified referral.
     * Update referral
     */
    async updateReferralRaw(requestParameters: UpdateReferralRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Referral>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling updateReferral().'
            );
        }

        if (requestParameters['campaignId'] == null) {
            throw new runtime.RequiredError(
                'campaignId',
                'Required parameter "campaignId" was null or undefined when calling updateReferral().'
            );
        }

        if (requestParameters['referralId'] == null) {
            throw new runtime.RequiredError(
                'referralId',
                'Required parameter "referralId" was null or undefined when calling updateReferral().'
            );
        }

        if (requestParameters['updateReferral'] == null) {
            throw new runtime.RequiredError(
                'updateReferral',
                'Required parameter "updateReferral" was null or undefined when calling updateReferral().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/campaigns/{campaignId}/referrals/{referralId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"campaignId"}}`, encodeURIComponent(String(requestParameters['campaignId'])));
        urlPath = urlPath.replace(`{${"referralId"}}`, encodeURIComponent(String(requestParameters['referralId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateReferralToJSON(requestParameters['updateReferral']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ReferralFromJSON(jsonValue));
    }

    /**
     * Update the specified referral.
     * Update referral
     */
    async updateReferral(requestParameters: UpdateReferralRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Referral> {
        const response = await this.updateReferralRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a specific role.
     * Update role
     */
    async updateRoleV2Raw(requestParameters: UpdateRoleV2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RoleV2>> {
        if (requestParameters['roleId'] == null) {
            throw new runtime.RequiredError(
                'roleId',
                'Required parameter "roleId" was null or undefined when calling updateRoleV2().'
            );
        }

        if (requestParameters['roleV2Base'] == null) {
            throw new runtime.RequiredError(
                'roleV2Base',
                'Required parameter "roleV2Base" was null or undefined when calling updateRoleV2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v2/roles/{roleId}`;
        urlPath = urlPath.replace(`{${"roleId"}}`, encodeURIComponent(String(requestParameters['roleId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RoleV2BaseToJSON(requestParameters['roleV2Base']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleV2FromJSON(jsonValue));
    }

    /**
     * Update a specific role.
     * Update role
     */
    async updateRoleV2(requestParameters: UpdateRoleV2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RoleV2> {
        const response = await this.updateRoleV2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update store details for a specific store ID.
     * Update store
     */
    async updateStoreRaw(requestParameters: UpdateStoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Store>> {
        if (requestParameters['applicationId'] == null) {
            throw new runtime.RequiredError(
                'applicationId',
                'Required parameter "applicationId" was null or undefined when calling updateStore().'
            );
        }

        if (requestParameters['storeId'] == null) {
            throw new runtime.RequiredError(
                'storeId',
                'Required parameter "storeId" was null or undefined when calling updateStore().'
            );
        }

        if (requestParameters['newStore'] == null) {
            throw new runtime.RequiredError(
                'newStore',
                'Required parameter "newStore" was null or undefined when calling updateStore().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/applications/{applicationId}/stores/{storeId}`;
        urlPath = urlPath.replace(`{${"applicationId"}}`, encodeURIComponent(String(requestParameters['applicationId'])));
        urlPath = urlPath.replace(`{${"storeId"}}`, encodeURIComponent(String(requestParameters['storeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: NewStoreToJSON(requestParameters['newStore']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreFromJSON(jsonValue));
    }

    /**
     * Update store details for a specific store ID.
     * Update store
     */
    async updateStore(requestParameters: UpdateStoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Store> {
        const response = await this.updateStoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the details of a specific user.
     * Update user
     */
    async updateUserRaw(requestParameters: UpdateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<User>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling updateUser().'
            );
        }

        if (requestParameters['updateUser'] == null) {
            throw new runtime.RequiredError(
                'updateUser',
                'Required parameter "updateUser" was null or undefined when calling updateUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // management_key authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // manager_auth authentication
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key_v1 authentication
        }


        let urlPath = `/v1/users/{userId}`;
        urlPath = urlPath.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateUserToJSON(requestParameters['updateUser']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * Update the details of a specific user.
     * Update user
     */
    async updateUser(requestParameters: UpdateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<User> {
        const response = await this.updateUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const DeleteCampaignStoreBudgetsActionEnum = {
    SetDiscount: 'setDiscount'
} as const;
export type DeleteCampaignStoreBudgetsActionEnum = typeof DeleteCampaignStoreBudgetsActionEnum[keyof typeof DeleteCampaignStoreBudgetsActionEnum];
/**
 * @export
 */
export const DeleteCampaignStoreBudgetsPeriodEnum = {
    Overall: 'overall',
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly',
    Yearly: 'yearly'
} as const;
export type DeleteCampaignStoreBudgetsPeriodEnum = typeof DeleteCampaignStoreBudgetsPeriodEnum[keyof typeof DeleteCampaignStoreBudgetsPeriodEnum];
/**
 * @export
 */
export const DeleteCouponsValidEnum = {
    Expired: 'expired',
    ValidNow: 'validNow',
    ValidFuture: 'validFuture'
} as const;
export type DeleteCouponsValidEnum = typeof DeleteCouponsValidEnum[keyof typeof DeleteCouponsValidEnum];
/**
 * @export
 */
export const DeleteCouponsUsableEnum = {
    True: 'true',
    False: 'false'
} as const;
export type DeleteCouponsUsableEnum = typeof DeleteCouponsUsableEnum[keyof typeof DeleteCouponsUsableEnum];
/**
 * @export
 */
export const ExportCampaignStoreBudgetsActionEnum = {
    SetDiscount: 'setDiscount'
} as const;
export type ExportCampaignStoreBudgetsActionEnum = typeof ExportCampaignStoreBudgetsActionEnum[keyof typeof ExportCampaignStoreBudgetsActionEnum];
/**
 * @export
 */
export const ExportCampaignStoreBudgetsPeriodEnum = {
    Overall: 'overall',
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly',
    Yearly: 'yearly'
} as const;
export type ExportCampaignStoreBudgetsPeriodEnum = typeof ExportCampaignStoreBudgetsPeriodEnum[keyof typeof ExportCampaignStoreBudgetsPeriodEnum];
/**
 * @export
 */
export const ExportCouponsValidEnum = {
    Expired: 'expired',
    ValidNow: 'validNow',
    ValidFuture: 'validFuture'
} as const;
export type ExportCouponsValidEnum = typeof ExportCouponsValidEnum[keyof typeof ExportCouponsValidEnum];
/**
 * @export
 */
export const ExportCouponsUsableEnum = {
    True: 'true',
    False: 'false'
} as const;
export type ExportCouponsUsableEnum = typeof ExportCouponsUsableEnum[keyof typeof ExportCouponsUsableEnum];
/**
 * @export
 */
export const ExportCouponsDateFormatEnum = {
    Excel: 'excel',
    Iso8601: 'ISO8601'
} as const;
export type ExportCouponsDateFormatEnum = typeof ExportCouponsDateFormatEnum[keyof typeof ExportCouponsDateFormatEnum];
/**
 * @export
 */
export const ExportCouponsCampaignStateEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled',
    Archived: 'archived',
    Scheduled: 'scheduled',
    Running: 'running',
    Expired: 'expired',
    Staged: 'staged'
} as const;
export type ExportCouponsCampaignStateEnum = typeof ExportCouponsCampaignStateEnum[keyof typeof ExportCouponsCampaignStateEnum];
/**
 * @export
 */
export const ExportCustomerSessionsDateFormatEnum = {
    Excel: 'excel',
    Iso8601: 'ISO8601'
} as const;
export type ExportCustomerSessionsDateFormatEnum = typeof ExportCustomerSessionsDateFormatEnum[keyof typeof ExportCustomerSessionsDateFormatEnum];
/**
 * @export
 */
export const ExportCustomerSessionsCustomerSessionStateEnum = {
    Open: 'open',
    Closed: 'closed',
    PartiallyReturned: 'partially_returned',
    Cancelled: 'cancelled'
} as const;
export type ExportCustomerSessionsCustomerSessionStateEnum = typeof ExportCustomerSessionsCustomerSessionStateEnum[keyof typeof ExportCustomerSessionsCustomerSessionStateEnum];
/**
 * @export
 */
export const ExportEffectsDateFormatEnum = {
    Excel: 'excel',
    Iso8601: 'ISO8601'
} as const;
export type ExportEffectsDateFormatEnum = typeof ExportEffectsDateFormatEnum[keyof typeof ExportEffectsDateFormatEnum];
/**
 * @export
 */
export const ExportLoyaltyCardLedgerDateFormatEnum = {
    Excel: 'excel',
    Iso8601: 'ISO8601'
} as const;
export type ExportLoyaltyCardLedgerDateFormatEnum = typeof ExportLoyaltyCardLedgerDateFormatEnum[keyof typeof ExportLoyaltyCardLedgerDateFormatEnum];
/**
 * @export
 */
export const ExportLoyaltyCardsDateFormatEnum = {
    Excel: 'excel',
    Iso8601: 'ISO8601'
} as const;
export type ExportLoyaltyCardsDateFormatEnum = typeof ExportLoyaltyCardsDateFormatEnum[keyof typeof ExportLoyaltyCardsDateFormatEnum];
/**
 * @export
 */
export const ExportLoyaltyLedgerDateFormatEnum = {
    Excel: 'excel',
    Iso8601: 'ISO8601'
} as const;
export type ExportLoyaltyLedgerDateFormatEnum = typeof ExportLoyaltyLedgerDateFormatEnum[keyof typeof ExportLoyaltyLedgerDateFormatEnum];
/**
 * @export
 */
export const ExportReferralsValidEnum = {
    Expired: 'expired',
    ValidNow: 'validNow',
    ValidFuture: 'validFuture'
} as const;
export type ExportReferralsValidEnum = typeof ExportReferralsValidEnum[keyof typeof ExportReferralsValidEnum];
/**
 * @export
 */
export const ExportReferralsUsableEnum = {
    True: 'true',
    False: 'false'
} as const;
export type ExportReferralsUsableEnum = typeof ExportReferralsUsableEnum[keyof typeof ExportReferralsUsableEnum];
/**
 * @export
 */
export const ExportReferralsDateFormatEnum = {
    Excel: 'excel',
    Iso8601: 'ISO8601'
} as const;
export type ExportReferralsDateFormatEnum = typeof ExportReferralsDateFormatEnum[keyof typeof ExportReferralsDateFormatEnum];
/**
 * @export
 */
export const GetAccessLogsWithoutTotalCountMethodEnum = {
    Get: 'get',
    Put: 'put',
    Post: 'post',
    Delete: 'delete',
    Patch: 'patch'
} as const;
export type GetAccessLogsWithoutTotalCountMethodEnum = typeof GetAccessLogsWithoutTotalCountMethodEnum[keyof typeof GetAccessLogsWithoutTotalCountMethodEnum];
/**
 * @export
 */
export const GetAccessLogsWithoutTotalCountStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;
export type GetAccessLogsWithoutTotalCountStatusEnum = typeof GetAccessLogsWithoutTotalCountStatusEnum[keyof typeof GetAccessLogsWithoutTotalCountStatusEnum];
/**
 * @export
 */
export const GetApplicationSessionsStateEnum = {
    Open: 'open',
    Closed: 'closed',
    PartiallyReturned: 'partially_returned',
    Cancelled: 'cancelled'
} as const;
export type GetApplicationSessionsStateEnum = typeof GetApplicationSessionsStateEnum[keyof typeof GetApplicationSessionsStateEnum];
/**
 * @export
 */
export const GetAttributesKindEnum = {
    Builtin: 'builtin',
    Custom: 'custom'
} as const;
export type GetAttributesKindEnum = typeof GetAttributesKindEnum[keyof typeof GetAttributesKindEnum];
/**
 * @export
 */
export const GetCampaignAnalyticsGranularityEnum = {
    _1Hour: '1 hour',
    _1Day: '1 day',
    _1Week: '1 week',
    _1Month: '1 month',
    _1Year: '1 year'
} as const;
export type GetCampaignAnalyticsGranularityEnum = typeof GetCampaignAnalyticsGranularityEnum[keyof typeof GetCampaignAnalyticsGranularityEnum];
/**
 * @export
 */
export const GetCampaignByAttributesCampaignStateEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled',
    Archived: 'archived',
    Scheduled: 'scheduled',
    Running: 'running',
    Expired: 'expired',
    Staged: 'staged'
} as const;
export type GetCampaignByAttributesCampaignStateEnum = typeof GetCampaignByAttributesCampaignStateEnum[keyof typeof GetCampaignByAttributesCampaignStateEnum];
/**
 * @export
 */
export const GetCampaignTemplatesStateEnum = {
    Draft: 'draft',
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;
export type GetCampaignTemplatesStateEnum = typeof GetCampaignTemplatesStateEnum[keyof typeof GetCampaignTemplatesStateEnum];
/**
 * @export
 */
export const GetCampaignsCampaignStateEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled',
    Archived: 'archived',
    Scheduled: 'scheduled',
    Running: 'running',
    Expired: 'expired',
    Staged: 'staged'
} as const;
export type GetCampaignsCampaignStateEnum = typeof GetCampaignsCampaignStateEnum[keyof typeof GetCampaignsCampaignStateEnum];
/**
 * @export
 */
export const GetCouponsWithoutTotalCountValidEnum = {
    Expired: 'expired',
    ValidNow: 'validNow',
    ValidFuture: 'validFuture'
} as const;
export type GetCouponsWithoutTotalCountValidEnum = typeof GetCouponsWithoutTotalCountValidEnum[keyof typeof GetCouponsWithoutTotalCountValidEnum];
/**
 * @export
 */
export const GetCouponsWithoutTotalCountUsableEnum = {
    True: 'true',
    False: 'false'
} as const;
export type GetCouponsWithoutTotalCountUsableEnum = typeof GetCouponsWithoutTotalCountUsableEnum[keyof typeof GetCouponsWithoutTotalCountUsableEnum];
/**
 * @export
 */
export const GetCouponsWithoutTotalCountRedeemedEnum = {
    True: 'true',
    False: 'false'
} as const;
export type GetCouponsWithoutTotalCountRedeemedEnum = typeof GetCouponsWithoutTotalCountRedeemedEnum[keyof typeof GetCouponsWithoutTotalCountRedeemedEnum];
/**
 * @export
 */
export const GetExportsEntityEnum = {
    Coupon: 'Coupon',
    Referral: 'Referral',
    Effect: 'Effect',
    CustomerSession: 'CustomerSession',
    LoyaltyLedger: 'LoyaltyLedger',
    LoyaltyLedgerLog: 'LoyaltyLedgerLog',
    Collection: 'Collection',
    AudienceMembership: 'AudienceMembership'
} as const;
export type GetExportsEntityEnum = typeof GetExportsEntityEnum[keyof typeof GetExportsEntityEnum];
/**
 * @export
 */
export const GetLoyaltyProgramProfileLedgerTransactionsLoyaltyTransactionTypeEnum = {
    Manual: 'manual',
    Session: 'session',
    Import: 'import'
} as const;
export type GetLoyaltyProgramProfileLedgerTransactionsLoyaltyTransactionTypeEnum = typeof GetLoyaltyProgramProfileLedgerTransactionsLoyaltyTransactionTypeEnum[keyof typeof GetLoyaltyProgramProfileLedgerTransactionsLoyaltyTransactionTypeEnum];
/**
 * @export
 */
export const GetLoyaltyProgramTransactionsLoyaltyTransactionTypeEnum = {
    Manual: 'manual',
    Session: 'session',
    Import: 'import'
} as const;
export type GetLoyaltyProgramTransactionsLoyaltyTransactionTypeEnum = typeof GetLoyaltyProgramTransactionsLoyaltyTransactionTypeEnum[keyof typeof GetLoyaltyProgramTransactionsLoyaltyTransactionTypeEnum];
/**
 * @export
 */
export const GetMessageLogsEntityTypeEnum = {
    Application: 'application',
    LoyaltyProgram: 'loyalty_program',
    Webhook: 'webhook'
} as const;
export type GetMessageLogsEntityTypeEnum = typeof GetMessageLogsEntityTypeEnum[keyof typeof GetMessageLogsEntityTypeEnum];
/**
 * @export
 */
export const GetMessageLogsChangeTypeEnum = {
    CampaignEvaluationTreeChanged: 'CampaignEvaluationTreeChanged',
    CampaignNotification: 'CampaignNotification',
    CouponCreated: 'CouponCreated',
    CouponUpdated: 'CouponUpdated',
    CouponDeleted: 'CouponDeleted',
    AsyncCouponsCreated: 'AsyncCouponsCreated',
    CouponsDeleted: 'CouponsDeleted',
    CouponsUpdated: 'CouponsUpdated',
    CouponCodeExpiring: 'CouponCodeExpiring',
    StrikethroughPrice: 'StrikethroughPrice',
    LoyaltyPointsAdded: 'LoyaltyPointsAdded',
    LoyaltyPointsDeducted: 'LoyaltyPointsDeducted',
    LoyaltyPointsExpiring: 'LoyaltyPointsExpiring',
    LoyaltyPointsPendingToActive: 'LoyaltyPointsPendingToActive',
    LoyaltyAddedDeductedPointsBalances: 'LoyaltyAddedDeductedPointsBalances',
    LoyaltyCardAddedDeductedPointsBalances: 'LoyaltyCardAddedDeductedPointsBalances',
    TierWillDowngrade: 'TierWillDowngrade',
    TierUpgrade: 'TierUpgrade',
    TierDowngrade: 'TierDowngrade',
    LoyaltyCardPointsAdded: 'LoyaltyCardPointsAdded',
    LoyaltyCardPointsDeducted: 'LoyaltyCardPointsDeducted',
    LoyaltyCardPointsExpiring: 'LoyaltyCardPointsExpiring'
} as const;
export type GetMessageLogsChangeTypeEnum = typeof GetMessageLogsChangeTypeEnum[keyof typeof GetMessageLogsChangeTypeEnum];
/**
 * @export
 */
export const GetMessageLogsPeriodEnum = {
    _15m: '15m',
    _30m: '30m',
    _1h: '1h',
    _4h: '4h',
    _1d: '1d',
    _2d: '2d'
} as const;
export type GetMessageLogsPeriodEnum = typeof GetMessageLogsPeriodEnum[keyof typeof GetMessageLogsPeriodEnum];
/**
 * @export
 */
export const GetReferralsWithoutTotalCountValidEnum = {
    Expired: 'expired',
    ValidNow: 'validNow',
    ValidFuture: 'validFuture'
} as const;
export type GetReferralsWithoutTotalCountValidEnum = typeof GetReferralsWithoutTotalCountValidEnum[keyof typeof GetReferralsWithoutTotalCountValidEnum];
/**
 * @export
 */
export const GetReferralsWithoutTotalCountUsableEnum = {
    True: 'true',
    False: 'false'
} as const;
export type GetReferralsWithoutTotalCountUsableEnum = typeof GetReferralsWithoutTotalCountUsableEnum[keyof typeof GetReferralsWithoutTotalCountUsableEnum];
/**
 * @export
 */
export const GetWebhooksCreationTypeEnum = {
    TemplateWebhooks: 'templateWebhooks',
    Webhooks: 'webhooks'
} as const;
export type GetWebhooksCreationTypeEnum = typeof GetWebhooksCreationTypeEnum[keyof typeof GetWebhooksCreationTypeEnum];
/**
 * @export
 */
export const GetWebhooksVisibilityEnum = {
    Visible: 'visible',
    Hidden: 'hidden'
} as const;
export type GetWebhooksVisibilityEnum = typeof GetWebhooksVisibilityEnum[keyof typeof GetWebhooksVisibilityEnum];
/**
 * @export
 */
export const ImportCampaignStoreBudgetActionEnum = {
    SetDiscount: 'setDiscount'
} as const;
export type ImportCampaignStoreBudgetActionEnum = typeof ImportCampaignStoreBudgetActionEnum[keyof typeof ImportCampaignStoreBudgetActionEnum];
/**
 * @export
 */
export const ImportCampaignStoreBudgetPeriodEnum = {
    Overall: 'overall',
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly',
    Yearly: 'yearly'
} as const;
export type ImportCampaignStoreBudgetPeriodEnum = typeof ImportCampaignStoreBudgetPeriodEnum[keyof typeof ImportCampaignStoreBudgetPeriodEnum];
/**
 * @export
 */
export const ListCampaignStoreBudgetLimitsActionEnum = {
    SetDiscount: 'setDiscount'
} as const;
export type ListCampaignStoreBudgetLimitsActionEnum = typeof ListCampaignStoreBudgetLimitsActionEnum[keyof typeof ListCampaignStoreBudgetLimitsActionEnum];
/**
 * @export
 */
export const ListCampaignStoreBudgetLimitsPeriodEnum = {
    Overall: 'overall',
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly',
    Yearly: 'yearly'
} as const;
export type ListCampaignStoreBudgetLimitsPeriodEnum = typeof ListCampaignStoreBudgetLimitsPeriodEnum[keyof typeof ListCampaignStoreBudgetLimitsPeriodEnum];
/**
 * @export
 */
export const SearchCouponsAdvancedApplicationWideWithoutTotalCountValidEnum = {
    Expired: 'expired',
    ValidNow: 'validNow',
    ValidFuture: 'validFuture'
} as const;
export type SearchCouponsAdvancedApplicationWideWithoutTotalCountValidEnum = typeof SearchCouponsAdvancedApplicationWideWithoutTotalCountValidEnum[keyof typeof SearchCouponsAdvancedApplicationWideWithoutTotalCountValidEnum];
/**
 * @export
 */
export const SearchCouponsAdvancedApplicationWideWithoutTotalCountUsableEnum = {
    True: 'true',
    False: 'false'
} as const;
export type SearchCouponsAdvancedApplicationWideWithoutTotalCountUsableEnum = typeof SearchCouponsAdvancedApplicationWideWithoutTotalCountUsableEnum[keyof typeof SearchCouponsAdvancedApplicationWideWithoutTotalCountUsableEnum];
/**
 * @export
 */
export const SearchCouponsAdvancedApplicationWideWithoutTotalCountCampaignStateEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled',
    Archived: 'archived',
    Scheduled: 'scheduled',
    Running: 'running',
    Expired: 'expired',
    Staged: 'staged'
} as const;
export type SearchCouponsAdvancedApplicationWideWithoutTotalCountCampaignStateEnum = typeof SearchCouponsAdvancedApplicationWideWithoutTotalCountCampaignStateEnum[keyof typeof SearchCouponsAdvancedApplicationWideWithoutTotalCountCampaignStateEnum];
/**
 * @export
 */
export const SearchCouponsAdvancedWithoutTotalCountValidEnum = {
    Expired: 'expired',
    ValidNow: 'validNow',
    ValidFuture: 'validFuture'
} as const;
export type SearchCouponsAdvancedWithoutTotalCountValidEnum = typeof SearchCouponsAdvancedWithoutTotalCountValidEnum[keyof typeof SearchCouponsAdvancedWithoutTotalCountValidEnum];
/**
 * @export
 */
export const SearchCouponsAdvancedWithoutTotalCountUsableEnum = {
    True: 'true',
    False: 'false'
} as const;
export type SearchCouponsAdvancedWithoutTotalCountUsableEnum = typeof SearchCouponsAdvancedWithoutTotalCountUsableEnum[keyof typeof SearchCouponsAdvancedWithoutTotalCountUsableEnum];
